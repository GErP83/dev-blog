<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>All about authentication in Vapor 4 - The.Swift.Dev.</title>
    
    <meta name="description" content="Learn how to implement a user login mechanism with various auth methods using sessions, JWTs, written in Swift only.">
    
    <meta property="og:title" content="All about authentication in Vapor 4 - The.Swift.Dev.">
    <meta property="og:description" content="Learn how to implement a user login mechanism with various auth methods using sessions, JWTs, written in Swift only.">
    <meta property="og:url" content="https://theswiftdev.com/all-about-authentication-in-vapor-4">
    <meta property="og:image" content="https://theswiftdev.com/images/assets/all-about-authentication-in-vapor-4/cover.jpg">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@tiborbodecs">
    <meta name="twitter:creator" content="@tiborbodecs">
    <meta name="twitter:title" content="All about authentication in Vapor 4 - The.Swift.Dev.">
    <meta name="twitter:description" content="Learn how to implement a user login mechanism with various auth methods using sessions, JWTs, written in Swift only.">
    <meta name="twitter:image" content="https://theswiftdev.com/images/assets/all-about-authentication-in-vapor-4/cover.jpg">
    
    <link rel="stylesheet" href="https://theswiftdev.com/css/style.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/syntax.css">
    
    <link rel="mask-icon" sizes="any" href="https://theswiftdev.com/images/icons/icon.svg">

    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="https://theswiftdev.com/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="https://theswiftdev.com/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://theswiftdev.com/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://theswiftdev.com/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://theswiftdev.com/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://theswiftdev.com/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://theswiftdev.com/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://theswiftdev.com/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://theswiftdev.com/images/icons/apple-touch-icon-180x180.png">
    
</head>

<body>
    <a href="https://theswiftdev.gumroad.com" class="ribbon">
        üìñ
    </a>
    <header id="page-header">
        <a href="https://theswiftdev.com/">
            <img 
                id="logo-image"
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >
        </a>
    </header>
    
    <main>

        <article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2020/04/07">2020/04/07</time>
            <h1 class="title">All about authentication in Vapor 4</h1>
            <p class="excerpt">Learn how to implement a user login mechanism with various auth methods using sessions, JWTs, written in Swift only.</p>
            <div class="meta">
                <span class="tag">Vapor</span>
<span class="tag">authentication</span>
            </div>
        </section>
        <section class="wrapper">
            <img id="post-image" src="https://theswiftdev.com/images/assets/all-about-authentication-in-vapor-4/cover.jpg">
        </section>
    </header>

    <div id="contents">
        <section class="content-wrapper">
            <h2>Authentication, authorization, sessions, tokens what the f*** is this all about???</h2><p>The official Vapor docs about <a href="http://docs.vapor.codes/4.0/authentication/" target="_blank">authentication</a> are pretty good, but for a beginner it can be a little hard to understand, since it covers a lot. In this article I'll try to explain everything as simple as possible from a different perspective. First let's define some basic terms.</p><h3>Authentication</h3><blockquote><p>Authentication is the act of verifying a user's identity.</p></blockquote><p>In other words, authentication is the process of transforming a unique key (identifier) to actual user data. This can be a cookie with a session identifier stored in a browser, or another one kept by the API client, but based on this id the backend can retrieve the associated user object.</p><p>The end user signs in using a login form on a website (or an API endpoint), sends the usual credentials (email, password) to the backend. If those credentials were valid, then the server will return a (randomly generated) identifier to the client. We usually call this identifier, session or token, based on some other principles I'll cover later on. ‚¨áÔ∏è</p><p>Next time the client wants to make a request it just needs to send the locally stored id, instead of the sensitive email, password combination. The server just needs to validate the id somehow, if it's valid then the user is authenticated, we can use it to fetch more details about the user.</p><h3>Authorization</h3><blockquote><p>The act of verifying a previously authenticated user's permissions to perform certain tasks.</p></blockquote><p>How do we know if the authenticated user has access to some endpoint on the server? Is it just a regular visitor, or an admin user? The method of figuring out user roles, permissions, access level is called authorization. It ensures that the authorized user can only access specific resources. üîí</p><p>Consider the following scenario: there are two types of user roles: editors and visitors. An editor can create a new article, but a visitor can only view them (these are the permissions associated to the roles). <code>EditorUser</code> is in the group of editors, but <code>VisitorUser</code> only has the visitor role. We can figure out the authority (access level) for each user by checking the roles &amp; permissions.</p><p class="note">Session ID ~(authentication)~&gt; User ~(authorization)~&gt; Roles &amp; Permissions</p><p>Vapor only gives you some help to authenticate the user using various methods. Authorization is usually part of your app's business logic, this means that you have to figure out the details for your own needs, but this is just fine, don't worry too much about it just yet. üò¨</p><h3>Sessions</h3><blockquote><p>If there is a record on the server side with an identifier, then it is a session.</p></blockquote><p>For the sake of simplicity, let's say that a session is something that you can look up on the server inside some kind of storage. This session is linked to exactly one user account so when you receive a session identifier you can look up the corresponding user through the relation.</p><p>The session identifier is exchanged to the client after a successful email + password based login request. The client stores session id somewhere for further usage. The storage can be anything, but browsers mainly use cookies or the local storage. Applications can store session identifiers in the keychain, but I've seen some really bad practices using a plain-text file. üôâ</p><h3>Tokens</h3><p>Tokens (JWTs) on the other hand have no server side records. A token can be given to the client by the authentication API after a successful login request. The key difference between a token and a session is that a token is cryptographically signed. Thanks to asymmetric keys, the signature can be verified by the application server without knowing the private key that was used to sign the token. A token usually self-contains some other info about the user, expiration date, etc. This additional "metadata" can also be verified by the server, this gives us an extra layer of security.</p><p>Nowadays <a href="https://jwt.io/" target="_blank">JSON Web Token</a> is the golden standard if it comes to tokens. JWT is getting more and more popular, implementations are available for almost every programming language with a wide variety of signing algorithms. There is a really amazing <a href="https://blog.angular-university.io/angular-jwt/" target="_blank">guide to JSON Web Tokens</a>, you should definitely read it if you want to know more about this technology. üìñ</p><p>Enough theory, time to write some code using Swift on the server.</p><h2>Implementing auth methods in Vapor</h2><p>As I mentioned this in the beginning of the article authentication is simply turning a request into actual user data. Vapor has built-in protocols to help us during the process. There is quite an abstraction layer here, which means that you don't have to dig yourself into HTTP headers or incoming body parameters, but you can work with higher level functions to verify identify.</p><p>Let me show you all the auth protocols from Vapor 4 and how you can use them in practice. Remember: authentication in Vapor is about turning requests into models using the input.</p><h3>Authentication using a Model</h3><p>Each and every authentication protocol requires a model that is going to be retrieved during the authentication process. In this example I'll work with a <code>UserModel</code> entity, here's mine:</p><pre><code class="language-swift"><span class="keyword">import</span> Vapor
<span class="keyword">import</span> Fluent

<span class="keyword">final class</span> UserModel: <span class="type">Model</span> {
        
    <span class="keyword">static let</span> schema = <span class="string">"users"</span>

    <span class="keyword">struct</span> FieldKeys {
        <span class="keyword">static var</span> email: <span class="type">FieldKey</span> { <span class="string">"email"</span> }
        <span class="keyword">static var</span> password: <span class="type">FieldKey</span> { <span class="string">"password"</span> }
    }
    
    <span class="comment">// MARK: - fields</span>
    
    <span class="keyword">@ID</span>() <span class="keyword">var</span> id: <span class="type">UUID</span>?
    <span class="keyword">@Field</span>(key: <span class="type">FieldKeys</span>.<span class="property">email</span>) <span class="keyword">var</span> email: <span class="type">String</span>
    <span class="keyword">@Field</span>(key: <span class="type">FieldKeys</span>.<span class="property">password</span>) <span class="keyword">var</span> password: <span class="type">String</span>
    
    <span class="keyword">init</span>() { }
    
    <span class="keyword">init</span>(id: <span class="type">UserModel</span>.<span class="type">IDValue</span>? = <span class="keyword">nil</span>,
         email: <span class="type">String</span>,
         password: <span class="type">String</span>)
    {
        <span class="keyword">self</span>.<span class="property">id</span> = id
        <span class="keyword">self</span>.<span class="property">email</span> = email
        <span class="keyword">self</span>.<span class="property">password</span> = password
    }
}</code></pre><p>If you don't understand the code above, please read my <a href="https://theswiftdev.com/a-tutorial-for-beginners-about-the-fluent-postgresql-driver-in-vapor-4/">comprehensive tutorial about Fluent</a>, for now I'll skip the migration part, so you have to write that on your own to make things work. ‚ö†Ô∏è</p><p>Now that we have a model, it's time to convert an incoming request to an authenticated model using an authenticator object. Let's begin with the most simple one:</p><h3>RequestAuthenticator</h3><p>This comes handy if you have a custom authentication logic and you need the entire request object. Implementing the protocol is relatively straightforward. Imagine that some dumb-ass manager wants to authenticate users using the <a href="https://en.wikipedia.org/wiki/Fragment_identifier" target="_blank">fragment identifier</a> from the URL.</p><p>Not the smartest way of creating a safe authentication layer, but let's make him happy with a nice solution. Again, if you can guess the user identifier and you pass it as a fragment, you're signed in. (e.g. <code>http://localhost:8080/sign-in#</code>). If a user exists in the database with the provided UUID then we'll authenticate it (yes without providing a password ü§¶‚Äç‚ôÇÔ∏è), otherwise we'll respond with an error code.</p><pre><code class="language-swift"><span class="keyword">import</span> Vapor
<span class="keyword">import</span> Fluent

<span class="keyword">extension</span> <span class="type">UserModel</span>: <span class="type">Authenticatable</span> {}

<span class="keyword">struct</span> UserModelFragmentAuthenticator: <span class="type">RequestAuthenticator</span> {
    <span class="keyword">typealias</span> User = <span class="type">UserModel</span>

    <span class="keyword">func</span> authenticate(request: <span class="type">Request</span>) -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Void</span>&gt; {
        <span class="type">User</span>.<span class="call">find</span>(<span class="type">UUID</span>(uuidString: request.<span class="property">url</span>.<span class="property">fragment</span> ?? <span class="string">""</span>), on: request.<span class="property">db</span>)
        .<span class="call">map</span> {
            <span class="keyword">if let</span> user = $0 {
                request.<span class="property">auth</span>.<span class="call">login</span>(user)
            }
        }
    }
}</code></pre><p>Firstly, we create a <code>typealias</code> for the associated User type as our <code>UserModel</code>. It is a generic protocol, that's why you need the <code>typealias</code>.</p><blockquote><p>Inside the authenticator implementation you should look up the given user based on the incoming data, and if everything is valid you can simply call the <code>req.auth.login([user])</code> method, this will authenticate the user. You should return a <code>Void</code> future from these authenticator protocol methods, but please don't throw user related errors or use failed futures in this case. You should only supposed to forward database related errors or similar. If the authenticator can't log in the user, just don't call the login method, it's that simple.</p></blockquote><p>The second and final step is to write our authentication logic, in the auth method. You'll get the request as an input, and you have to return a future with the authenticated user or <code>nil</code> if the authentication was unsuccesful. Pretty easy, fragment is available through the request, and you can look up the entity using Fluent. That's it, we're ready. üòÖ</p><p class="warning">The fragment URL part is never going to be available on the server side at all. üí°</p><p>How do we use this authenticator? Well the Authenticator protocol itself extends the <a href="https://theswiftdev.com/how-to-use-middlewares-in-vapor-4/">Middleware</a> protocol, so we can register it right away as a group member. You can use a middleware to alter incoming requests before the next request handler will be called. This definition fits perfectly for the authenticators so it makes sense that they are defined as middlewares.</p><p>We'll need one more (guard) middleware that's coming from the <code>Authenticatable</code> protocol to respond with an error to unauthenticated requests.</p><pre><code class="language-swift"><span class="keyword">func</span> routes(<span class="keyword">_</span> app: <span class="type">Application</span>) <span class="keyword">throws</span> {
    
    app.<span class="call">grouped</span>(<span class="type">UserModelFragmentAuthenticator</span>(),
                <span class="type">UserModel</span>.<span class="call">guardMiddleware</span>())
    .<span class="call">get</span>(<span class="string">"sign-in"</span>) { req <span class="keyword">in</span>
        <span class="string">"I'm authenticated"</span>
    }
}</code></pre><p>Now if you navigate to the <code>http://localhost:8080/sign-in#</code> URL, with a valid UUID of an existing user from the db, the page should display "I'm authenticated", otherwise you'll get an HTTP error. The magic happens in the background. I'll explain the flow one more time.</p><p>The "sign-in" route has two middlewares. The first one is the authenticator which will try to turn the request into a model using the implemented authentication method. If the authentication was succesful it'll store the user object inside a generic <code>request.auth</code> property.</p><p>The second middleware literally guards the route from unauthenticated requests. It checks the request.auth variable, if it contains an authenticated user object or not. If it finds a previously authenticated user it'll continue with the next handler, otherwise it'll throw an error. Vapor can automatically turn thrown errors into HTTP status codes, that's why you'll get a 401.</p><p class="warning">The names of the HTTP standard response codes are a little big misleading. You should respond with 401 (unauthorized) for unsuccesful authentication requests, and 403 (forbidden) responses for unauthorized requests. Strange, huh? üò≥</p><p>You don't necessary need this second middleware, but I'd recommend using it. You can manually check the existence of an authenticated object using try <code>req.auth.require(UserModel.self)</code> inside the request handler. A guard middleware is available on every <code>Authenticatable</code> object, essentially it is doing the same thing as I mentioned above, but in a more generic, reusable way.</p><p>Finally the request handler will only be called if the user is already authenticated, otherwise it'll never be executed. This is how you can protect routes from unauthenticated requests.</p><h3>BasicAuthenticator</h3><p>A <code>BasicAuthenticator</code> is just an extension over the <code>RequestAuthenticator</code> protocol. During a <a href="https://en.wikipedia.org/wiki/Basic_access_authentication" target="_blank">basic authentication</a> the credentials are arriving base64 encoded inside the Authorization HTTP header. The format is <code>Authorization: Basic email:password</code> where the email:password or username:password credentials are only base64 encoed. Vapor helps you with the decoding process, that's what the protocol adds over the top of the request authentication layer, so you can write a basic authenticator like this:</p><pre><code class="language-swift"><span class="keyword">struct</span> UserModelBasicAuthenticator: <span class="type">BasicAuthenticator</span> {

    <span class="keyword">typealias</span> User = <span class="type">UserModel</span>
    
    <span class="keyword">func</span> authenticate(basic: <span class="type">BasicAuthorization</span>, for request: <span class="type">Request</span>) -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Void</span>&gt; {
        <span class="type">User</span>.<span class="call">query</span>(on: request.<span class="property">db</span>)
            .<span class="call">filter</span>(\.<span class="property">$email</span> == basic.<span class="property">username</span>)
            .<span class="call">first</span>()
            .<span class="call">map</span> {
                <span class="keyword">do</span> {
                    <span class="keyword">if let</span> user = $0, <span class="keyword">try</span> <span class="type">Bcrypt</span>.<span class="call">verify</span>(basic.<span class="property">password</span>, created: user.<span class="property">password</span>) {
                        request.<span class="property">auth</span>.<span class="call">login</span>(user)
                    }
                }
                <span class="keyword">catch</span> {
                    <span class="comment">// do nothing...</span>
                }
        }
    }
}</code></pre><p>Usage is pretty much the same, you just swap the authenticator or you can combine this one with the previous one to support multiple authentication methods for a single route. üòâ</p><h4>Basic auth using the ModelAuthenticatable protocol</h4><p>You don't always need to implement your own custom BasicAuthenticator. You can conform to the ModelAuthenticatable protocol. This way you can just write a password verifier and the underlying generic protocol implementation will take care of the rest.</p><pre><code class="language-swift"><span class="keyword">extension</span> <span class="type">UserModel</span>: <span class="type">ModelAuthenticatable</span> {
    <span class="keyword">static let</span> usernameKey = \<span class="type">UserModel</span>.<span class="property">$email</span>
    <span class="keyword">static let</span> passwordHashKey = \<span class="type">UserModel</span>.<span class="property">$password</span>

    <span class="keyword">func</span> verify(password: <span class="type">String</span>) <span class="keyword">throws</span> -&gt; <span class="type">Bool</span> {
        <span class="keyword">try</span> <span class="type">Bcrypt</span>.<span class="call">verify</span>(password, created: <span class="keyword">self</span>.<span class="property">password</span>)
    }
}

<span class="comment">// usage</span>
<span class="type">UserModel</span>.<span class="call">authenticator</span>()</code></pre><p>This is pretty much the same as writing the <code>UserModelBasicAuthenticator</code>, the only difference is that this time I don't have to implement the entire authentication logic, but I can simply provide the keypath for the username and password hash, and I just write the verification method. üëç</p><h3>BearerAuthenticator</h3><p>The bearer authentication is just a schema where you can send tokens inside the Authorization HTTP header field after the Bearer keyword. Nowadays this is the recommended way of sending <a href="https://en.wikipedia.org/wiki/JSON_Web_Token" target="_blank">JWTs to the backend</a>. In this case Vapor helps you by fetching the value of the token.</p><pre><code class="language-swift"><span class="keyword">struct</span> UserModelBearerAuthenticator: <span class="type">BearerAuthenticator</span> {
    
    <span class="keyword">typealias</span> User = <span class="type">UserModel</span>
    
    <span class="keyword">func</span> authenticate(bearer: <span class="type">BearerAuthorization</span>, for request: <span class="type">Request</span>) -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Void</span>&gt; {
        <span class="comment">// perform auth using the bearer.token value here...</span>
    }
}</code></pre><h4>Custom Bearer auth using the ModelAuthenticatable protocol</h4><p>I lied a little bit in the beginning, regarding sessions and tokens. We developers can call something that's stored in a backend database as a token. Also we're using the Authorization HTTP header field to authenticate users. The joke must be true, if it comes to naming things we are the worst. üòÖ</p><p>Back to the topic, storing a token in the database is more like an extended session, but fine, let's just go with the token name this time. This <code>ModelUserToken</code> allows you to create a custom token in the database and use it to authenticate users through an <code>Authorization Bearer</code> header.</p><p>Let's make a new Fluent model with an associated user to see how this works in practice.</p><pre><code class="language-swift"><span class="keyword">final class</span> UserTokenModel: <span class="type">Model</span> {
   
   <span class="keyword">static let</span> schema = <span class="string">"tokens"</span>
   
   <span class="keyword">struct</span> FieldKeys {
       <span class="keyword">static var</span> value: <span class="type">FieldKey</span> { <span class="string">"value"</span> }
       <span class="keyword">static var</span> userId: <span class="type">FieldKey</span> { <span class="string">"user_id"</span> }
   }
   
   <span class="comment">// MARK: - fields</span>
   
   <span class="keyword">@ID</span>() <span class="keyword">var</span> id: <span class="type">UUID</span>?
   <span class="keyword">@Field</span>(key: <span class="type">FieldKeys</span>.<span class="property">value</span>) <span class="keyword">var</span> value: <span class="type">String</span>
   <span class="keyword">@Parent</span>(key: <span class="type">FieldKeys</span>.<span class="property">userId</span>) <span class="keyword">var</span> user: <span class="type">UserModel</span>

   <span class="keyword">init</span>() { }
   
   <span class="keyword">init</span>(id: <span class="type">UserTokenModel</span>.<span class="type">IDValue</span>? = <span class="keyword">nil</span>,
        value: <span class="type">String</span>,
        userId: <span class="type">UserModel</span>.<span class="type">IDValue</span>)
   {
       <span class="keyword">self</span>.<span class="property">id</span> = id
       <span class="keyword">self</span>.<span class="property">value</span> = value
       <span class="keyword">self</span>.<span class="property">$user</span>.<span class="property">id</span> = userId
   }
}</code></pre><p>Now all what's left to do is to extend the protocol by providing the required keyPaths. This protocol allows you to perform extra checks on a given token, such as expiration date. The good news is that the protocol gives you a <code>BearerAuthenticator</code> middleware as a "gratis".</p><pre><code class="language-swift"><span class="keyword">extension</span> <span class="type">UserTokenModel</span>: <span class="type">ModelAuthenticatable</span> {
   <span class="keyword">static let</span> valueKey = \<span class="type">UserTokenModel</span>.<span class="property">$value</span>
   <span class="keyword">static let</span> userKey = \<span class="type">UserTokenModel</span>.<span class="property">$user</span>
   
   <span class="keyword">var</span> isValid: <span class="type">Bool</span> {
       <span class="keyword">true</span> <span class="comment">// you can check expiration or anything else...</span>
   }
}

<span class="comment">// a middleware that confroms to the BearerAuthenticator protocol</span>
UserTokenModel.<span class="call">authenticator</span>()</code></pre><p>How do you give a token to the end user? Well, you can open up an endpoint with a basic auth protection, generate a token, save it to the database and finally return it back as a response. All of this is nicely written in the <a href="http://docs.vapor.codes/4.0/authentication/" target="_blank">official authentication docs</a> on the Vapor website. If you read that I belive that you'll understand the whole purpose of these protocols. üíß</p><h3>CredentialsAuthenticator</h3><p>This authenticator can decode a specific <code>Content</code> from the HTTP body, so you can use the type-safe content fields right ahead. For example this comes handy when you have a login form on your website and you would like to submit the credentails through it. Regular HTML forms can send values encoded as <code>multipart/form-data</code> using the body, Vapor can decode every field on the other side. Another example is when you are sending the email, password credentials as a JSON object through a post body. <code>curl -X POST "URL" -d '{"email": "", "password": ""}'</code></p><pre><code class="language-swift"><span class="keyword">struct</span> UserModelCredentialsAuthenticator: <span class="type">CredentialsAuthenticator</span> {
    
    <span class="keyword">struct</span> Input: <span class="type">Content</span> {
        <span class="keyword">let</span> email: <span class="type">String</span>
        <span class="keyword">let</span> password: <span class="type">String</span>
    }

    <span class="keyword">typealias</span> Credentials = <span class="type">Input</span>

    <span class="keyword">func</span> authenticate(credentials: <span class="type">Credentials</span>, for req: <span class="type">Request</span>) -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Void</span>&gt; {
        <span class="type">UserModel</span>.<span class="call">query</span>(on: req.<span class="property">db</span>)
            .<span class="call">filter</span>(\.<span class="property">$email</span> == credentials.<span class="property">email</span>)
            .<span class="call">first</span>()
            .<span class="call">map</span> {
                <span class="keyword">do</span> {
                    <span class="keyword">if let</span> user = $0, <span class="keyword">try</span> <span class="type">Bcrypt</span>.<span class="call">verify</span>(credentials.<span class="property">password</span>, created: user.<span class="property">password</span>) {
                        req.<span class="property">auth</span>.<span class="call">login</span>(user)
                    }
                }
                <span class="keyword">catch</span> {
                    <span class="comment">// do nothing...</span>
                }
            }
    }
}</code></pre><p>So as you can see most of these authenticator protocols are just helpers to transform HTTP data into Swift code. Nothing to worry about, you just have to know the right one for you needs.</p><p>So shouldn't we put the pieces together already? Yes, but if you want to know more about auth you should check the source of the <a href="https://github.com/vapor/vapor/blob/master/Tests/VaporTests/AuthenticationTests.swift" target="_blank">AuthenticationTests.swift</a> file in the Vapor package. Now let me show you how to implement a session auth for your website.</p><h2>Session based authentication</h2><p>By default sessions will be kept around until you restart the server (or it crashes). We can change this by <a href="https://github.com/vapor/fluent/blob/master/Sources/Fluent/Fluent%2BSessions.swift" target="_blank">persisting sessions</a> to an external storage, such as a Fluent database or a redis storage. In this example I'm going to show you how to setup sessions inside a postgresql database.</p><pre><code class="language-swift"><span class="keyword">import</span> Vapor
<span class="keyword">import</span> Fluent
<span class="keyword">import</span> FluentPostgresDriver

<span class="keyword">extension</span> <span class="type">Application</span> {
    <span class="keyword">static let</span> databaseUrl = <span class="type">URL</span>(string: <span class="type">Environment</span>.<span class="call">get</span>(<span class="string">"DB_URL"</span>)!)!
}

<span class="keyword">public func</span> configure(<span class="keyword">_</span> app: <span class="type">Application</span>) <span class="keyword">throws</span> {

    <span class="keyword">try</span> app.<span class="property">databases</span>.<span class="call">use</span>(.<span class="call">postgres</span>(url: <span class="type">Application</span>.<span class="property">databaseUrl</span>), as: .<span class="dotAccess">psql</span>)
    
    <span class="comment">// setup persistent sessions</span>
    app.<span class="property">sessions</span>.<span class="call">use</span>(.<span class="dotAccess">fluent</span>)
    app.<span class="property">migrations</span>.<span class="call">add</span>(<span class="type">SessionRecord</span>.<span class="property">migration</span>)
}</code></pre><p>Setting up persistent sessions using Fluent as a storage driver is just two lines of code. ‚ù§Ô∏è</p><pre><code class="language-swift"><span class="keyword">extension</span> <span class="type">UserModel</span>: <span class="type">SessionAuthenticatable</span> {
    <span class="keyword">typealias</span> SessionID = <span class="type">UUID</span>

    <span class="keyword">var</span> sessionID: <span class="type">SessionID</span> { <span class="keyword">self</span>.<span class="property">id</span>! }
}

<span class="keyword">struct</span> UserModelSessionAuthenticator: <span class="type">SessionAuthenticator</span> {

    <span class="keyword">typealias</span> User = <span class="type">UserModel</span>
    
    <span class="keyword">func</span> authenticate(sessionID: <span class="type">User</span>.<span class="type">SessionID</span>, for req: <span class="type">Request</span>) -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Void</span>&gt; {
        <span class="type">User</span>.<span class="call">find</span>(sessionID, on: req.<span class="property">db</span>).<span class="call">map</span> { user  <span class="keyword">in
            if let</span> user = user {
                req.<span class="property">auth</span>.<span class="call">login</span>(user)
            }
        }
    }
}</code></pre><p>As a next step you have to extend the UserModel with the unique session details, so the system can look up users based on the session id. Lastly you have to connect the routes.</p><pre><code class="language-swift"><span class="keyword">import</span> Vapor
<span class="keyword">import</span> Fluent

<span class="keyword">func</span> routes(<span class="keyword">_</span> app: <span class="type">Application</span>) <span class="keyword">throws</span> {

    <span class="keyword">let</span> session = app.<span class="property">routes</span>.<span class="call">grouped</span>([
        <span class="type">SessionsMiddleware</span>(session: app.<span class="property">sessions</span>.<span class="property">driver</span>),
        <span class="type">UserModelSessionAuthenticator</span>(),
        <span class="type">UserModelCredentialsAuthenticator</span>(),
    ])

    session.<span class="call">get</span> { req -&gt; <span class="type">Response</span> <span class="keyword">in
        guard let</span> user = req.<span class="property">auth</span>.<span class="call">get</span>(<span class="type">UserModel</span>.<span class="keyword">self</span>) <span class="keyword">else</span> {
            <span class="keyword">return</span> req.<span class="call">redirect</span>(to: <span class="string">"/sign-in"</span>)
        }

        <span class="keyword">let</span> body = <span class="string">"""
        &lt;b&gt;</span>\(user.<span class="property">email</span>)<span class="string">&lt;/b&gt; is logged in &lt;a href="/logout"&gt;Logout&lt;/a&gt;
        """</span>

        <span class="keyword">return</span> .<span class="keyword">init</span>(status: .<span class="dotAccess">ok</span>,
              version: req.<span class="property">version</span>,
              headers: <span class="type">HTTPHeaders</span>.<span class="keyword">init</span>([(<span class="string">"Content-Type"</span>, <span class="string">"text/html; charset=UTF-8"</span>)]),
              body: .<span class="keyword">init</span>(string: body))
    }
    
    session.<span class="call">get</span>(<span class="string">"sign-in"</span>) { req -&gt; <span class="type">Response</span> <span class="keyword">in
        let</span> body = <span class="string">"""
        &lt;form action="/sign-in" method="post"&gt;
            &lt;label for="email"&gt;Email:&lt;/label&gt;
            &lt;input type="email" id="email" name="email" value=""&gt;
            
            &lt;label for="password"&gt;Password:&lt;/label&gt;
            &lt;input type="password" id="password" name="password" value=""&gt;
            
            &lt;input type="submit" value="Submit"&gt;
        &lt;/form&gt;
        """</span>

        <span class="keyword">return</span> .<span class="keyword">init</span>(status: .<span class="dotAccess">ok</span>,
              version: req.<span class="property">version</span>,
              headers: <span class="type">HTTPHeaders</span>.<span class="keyword">init</span>([(<span class="string">"Content-Type"</span>, <span class="string">"text/html; charset=UTF-8"</span>)]),
              body: .<span class="keyword">init</span>(string: body))
    }

    session.<span class="call">post</span>(<span class="string">"sign-in"</span>) { req -&gt; <span class="type">Response</span> <span class="keyword">in
        guard let</span> user = req.<span class="property">auth</span>.<span class="call">get</span>(<span class="type">UserModel</span>.<span class="keyword">self</span>) <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="type">Abort</span>(.<span class="dotAccess">unauthorized</span>)
        }
        req.<span class="property">session</span>.<span class="call">authenticate</span>(user)
        <span class="keyword">return</span> req.<span class="call">redirect</span>(to: <span class="string">"/"</span>)
    }
    
    session.<span class="call">get</span>(<span class="string">"logout"</span>) { req -&gt; <span class="type">Response</span> <span class="keyword">in</span>
        req.<span class="property">auth</span>.<span class="call">logout</span>(<span class="type">UserModel</span>.<span class="keyword">self</span>)
        req.<span class="property">session</span>.<span class="call">unauthenticate</span>(<span class="type">UserModel</span>.<span class="keyword">self</span>)
        <span class="keyword">return</span> req.<span class="call">redirect</span>(to: <span class="string">"/"</span>)
    }

}</code></pre><p>First we setup the session routes by adding the sessions middleware using the database storage driver. Next we create an endpoint where we can display the profile if the user is authenticated, otherwise we redirect to the sign-in screen. The get sign in screen renders a basic HTML form (you can also use the Leaf templating engine for a better looking view) and the post sign-in route handles the authentication process. The <code>req.session.authenticate</code> method will store the current user info in the session storage. The logout route will remove the current user from the auth store, plus we'd also like to remove the associated user link from the session storage. That's it. üòé</p><h2>JWT based authentication</h2><p>Vapor 4 comes with great JWT support as an external Swift package:</p><pre><code class="language-swift"><span class="comment">// swift-tools-version:5.2</span>
<span class="keyword">import</span> PackageDescription

<span class="keyword">let</span> package = <span class="type">Package</span>(
    <span class="comment">//...</span>
    dependencies: [
        <span class="comment">//...</span>
        .<span class="call">package</span>(url: <span class="string">"https://github.com/vapor/jwt.git"</span>, from: <span class="string">"4.0.0-rc.1"</span>),
    ],
    targets: [
        .<span class="call">target</span>(name: <span class="string">"App"</span>, dependencies: [
            .<span class="call">product</span>(name: <span class="string">"JWT"</span>, package: <span class="string">"jwt"</span>),
            <span class="comment">//...</span>
        ]),
        <span class="comment">//...</span>
    ]
)</code></pre><p>In order to use sign and verify JWTs you'll need a key-pair. The lib can generate one for you on the fly, but that's not going to work so well, because each time you restart the application a new public and private key will be used in the core of the JWT signer. It's better to have one sitting somewhere on the disk, you can generate one (<a href="https://community.auth0.com/t/jwt-signing-algorithms-rs256-vs-hs256/7720" target="_blank">RS256</a>) by running:</p><pre><code class="language-sh">ssh-keygen -t rsa -b 4096 -m PEM -f jwtRS256.key
openssl rsa -in jwtRS256.key -pubout -outform PEM -out jwtRS256.key.pub
</code></pre><p>I usually put thes generated files into my working directory. Since the algorithm (RS256) I'm using to sign the token is asymmetric I'll create 2 signers with different identifiers. A private signer is used to sign JWTs, a public one is used to verify the signature of the incoming JWTs.</p><pre><code class="language-swift"><span class="keyword">import</span> Vapor
<span class="keyword">import</span> JWT

<span class="keyword">extension</span> <span class="type">String</span> {
    <span class="keyword">var</span> bytes: [<span class="type">UInt8</span>] { .<span class="keyword">init</span>(<span class="keyword">self</span>.<span class="property">utf8</span>) }
}

<span class="keyword">extension</span> <span class="type">JWKIdentifier</span> {
    <span class="keyword">static let</span> `public` = <span class="type">JWKIdentifier</span>(string: <span class="string">"public"</span>)
    <span class="keyword">static let</span> `private` = <span class="type">JWKIdentifier</span>(string: <span class="string">"private"</span>)
}

<span class="keyword">public func</span> configure(<span class="keyword">_</span> app: <span class="type">Application</span>) <span class="keyword">throws</span> {
    
    <span class="comment">//...</span>

    <span class="keyword">let</span> privateKey = <span class="keyword">try</span> <span class="type">String</span>(contentsOfFile: app.<span class="property">directory</span>.<span class="property">workingDirectory</span> + <span class="string">"jwtRS256.key"</span>)
    <span class="keyword">let</span> privateSigner = <span class="keyword">try</span> <span class="type">JWTSigner</span>.<span class="call">rs256</span>(key: .<span class="dotAccess">private</span><span class="keyword">(</span>pem: privateKey.<span class="property">bytes</span>))
    
    <span class="keyword">let</span> publicKey = <span class="keyword">try</span> <span class="type">String</span>(contentsOfFile: app.<span class="property">directory</span>.<span class="property">workingDirectory</span> + <span class="string">"jwtRS256.key.pub"</span>)
    <span class="keyword">let</span> publicSigner = <span class="keyword">try</span> <span class="type">JWTSigner</span>.<span class="call">rs256</span>(key: .<span class="dotAccess">public</span><span class="keyword">(</span>pem: publicKey.<span class="property">bytes</span>))
     
    app.<span class="property">jwt</span>.<span class="property">signers</span>.<span class="call">use</span>(privateSigner, kid: .<span class="dotAccess">private</span>)
    app.<span class="property">jwt</span>.<span class="property">signers</span>.<span class="call">use</span>(publicSigner, kid: .<span class="dotAccess">public</span>, isDefault: <span class="keyword">true</span>)
}</code></pre><p>Verifying and signing a token is just a one-liner. You can use some of the authenticators from above to pass around a token to the request handler, somewhat the same way as we did it in the sessions example. However you'll need to define a custom <code>JWTPayload</code> object that contains all the fields used in the token. This payload protocol should implement a verify method that can help you with the verification process. Here's a really simple example how to sign and return a JWTPayload:</p><pre><code class="language-swift"><span class="keyword">import</span> Vapor
<span class="keyword">import</span> JWT

<span class="keyword">struct</span> Example: <span class="type">JWTPayload</span> {
    <span class="keyword">var</span> test: <span class="type">String</span>

    <span class="keyword">func</span> verify(using signer: <span class="type">JWTSigner</span>) <span class="keyword">throws</span> {}
}

<span class="keyword">func</span> routes(<span class="keyword">_</span> app: <span class="type">Application</span>) <span class="keyword">throws</span> {
    <span class="keyword">let</span> jwt = app.<span class="call">grouped</span>(<span class="string">"jwt"</span>)

    jwt.<span class="call">get</span> { req <span class="keyword">in</span>
        <span class="comment">// sign the payload using the private key</span>
        <span class="keyword">try</span> req.<span class="property">jwt</span>.<span class="call">sign</span>(<span class="type">Example</span>(test: <span class="string">"Hello world!"</span>), kid: .<span class="dotAccess">private</span>)

        <span class="comment">// verify a token using the public key
        //try request.jwt.verify(token, as: Example.self)</span>
    }
}</code></pre><p>A payload contains small pieces of information (<a href="https://www.iana.org/assignments/jwt/jwt.xhtml" target="_blank">claims</a>). Each of them can be verified through the previously mentioned verify method. The good thing is that the JWT package comes with lots of handy claim types (including validators), feel free to pick the ones you need from the package (<code>JWTKit/Sources/Claims</code> directory). Since there are no official docs yet, you should check the source in this case, but don't be afraid claims are very easy to understand. ü§ê</p><pre><code class="language-swift"><span class="keyword">struct</span> TestPayload: <span class="type">JWTPayload</span>, <span class="type">Equatable</span> {
    <span class="keyword">var</span> sub: <span class="type">SubjectClaim</span> <span class="comment">// a subject claim</span>
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> admin: <span class="type">Bool</span>
    <span class="keyword">var</span> exp: <span class="type">ExpirationClaim</span> <span class="comment">// an expiration claim</span>

    <span class="keyword">func</span> verify(using signer: <span class="type">JWTSigner</span>) <span class="keyword">throws</span> {
        <span class="keyword">try self</span>.<span class="property">exp</span>.<span class="call">verifyNotExpired</span>()
    }
}
<span class="keyword">let</span> payload = <span class="type">TestPayload</span>(sub: <span class="string">"vapor"</span>,
                          name: <span class="string">"Foo"</span>,
                          admin: <span class="keyword">false</span>,
                          exp: .<span class="keyword">init</span>(value: .<span class="keyword">init</span>(timeIntervalSince1970: <span class="number">2_000_000_000</span>)))

<span class="keyword">let</span> signed = <span class="keyword">try</span> app.<span class="property">jwt</span>.<span class="property">signers</span>.<span class="call">get</span>(kid: .<span class="dotAccess">private</span>)!.<span class="call">sign</span>(payload)

<span class="comment">// Verification tests:
//print(try! app.jwt.signers.get()!.verify(signed.bytes, as: TestPayload.self) == payload)
//print(try! app.jwt.signers.get(kid: .private)!.verify(signed.bytes, as: TestPayload.self) == payload)</span></code></pre><p>Tokens can be verified using both the public &amp; the private keys. The public key can be shared with anyone, but you should NEVER give away the private key. There is an best practice to share keys with other parties called: <a href="https://auth0.com/docs/tokens/concepts/jwks" target="_blank">JWKS</a>. Vapor comes with JWKS support, so you can load keys from a remote URLs using this method. This time I won't get into the details, but I promise that I'm going to make a post about how to use JWKS endpoints later on (Sign in with Apple tutorial). üîë</p><p>Based on this article now you should be able to write your own authentication layer that can utilize a JWT token as a key. A possible authenticator implementation could look like this:</p><pre><code class="language-swift"><span class="keyword">extension</span> <span class="type">UserModel</span>: <span class="type">Authenticatable</span> {}

<span class="keyword">struct</span> JWTUserModelBearerAuthenticator: <span class="type">BearerAuthenticator</span> {
    <span class="keyword">typealias</span> User = <span class="type">UserModel</span>
    
    <span class="keyword">func</span> authenticate(bearer: <span class="type">BearerAuthorization</span>, for request: <span class="type">Request</span>) -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">User</span>?&gt; {
        <span class="keyword">do</span> {
            <span class="keyword">let</span> jwt = <span class="keyword">try</span> request.<span class="property">jwt</span>.<span class="call">verify</span>(bearer.<span class="property">token</span>, as: <span class="type">JWTAuth</span>.<span class="keyword">self</span>)
            <span class="keyword">return</span> <span class="type">User</span>.<span class="call">find</span>(<span class="type">UUID</span>(uuidString: jwt.<span class="property">userId</span>), on: request.<span class="property">db</span>)
        }
        <span class="keyword">catch</span> {
            <span class="keyword">return</span> request.<span class="property">eventLoop</span>.<span class="call">makeSucceededFuture</span>(<span class="keyword">nil</span>)
        }
    }
}</code></pre><p>The other thing that you'll need is an endpoint that can exchange a JWT for the login credentials. You can use some other authenticators to support multiple authentication methods, such as basic or credentials. Don't forget to guard the protected routes using the correct middleware. ü§î</p><h2>Conclusion</h2><p>Authentication is a really heavy topic, but fortunately Vapor helps a lot with the underlying tools. As you can see I tried to cover a lot in this artilce, but still I could write more about JWKS, OAuth, etc.</p><p>I really hope that you'll find this article useful to understand the basic concepts. The methods described here are not bulletproof, the purpose here is not to demonstrate a secure layer, but to educate people about how the authentication layer works in Vapor 4. Keep this in mind. üôè</p>
        </section>
    </div>

</article>

<section id="share" class="content-wrapper">
    <p>
    <a
        href="https://twitter.com/intent/tweet?via=tiborbodecs&amp;hashtags=SwiftLang&amp;url=https://theswiftdev.com/all-about-authentication-in-vapor-4"
        target="_blank"
    >
        Share this article on Twitter
    </a>
    <br> Thank you. üôè</p>
</section>

<section  class="wrapper">
    <div id="book">
        <div class="column left">
            <img src="https://theswiftdev.com/images/practical-server-side-swift-cover.png">
        </div>
        <div class="column right">
            <h3>Get the Practical Server Side Swift book</h3>
            <p>Swift on the server is an amazing new opportunity to build fast, safe and scalable backend apps. Write your very first web-based application by using your favorite programming language. Learn how to build a modular blog engine using the latest version of the Vapor 4 framework. This book will help you to design and create modern APIs that'll allow you to share code between the server side and iOS. Start becoming a full-stack Swift developer.</p>
            <a class="button" href="https://gumroad.com/l/practical-server-side-swift" target="_blank">Available on Gumroad</a>
        </div>
    </div>
</section>

<section id="author" class="content-wrapper">
    <img 
        id="author-image"
        src="https://theswiftdev.com/images/profiles/tiborbodecs.jpg"
        alt="Picture of Tibor B√∂decs" 
        title="Tibor B√∂decs"
    >
    <h3>Tibor B√∂decs</h3>
    <p class="title">CEO @ <a href="https://binarybirds.com/">Binary Birds</a></p>
    <p class="bio">Server side Swift enthusiast, book author, content creator.</p>

    <div class="links">
        <a href="mailto:mail.tib@gmail.com?subject=theswiftdev.com" target="_blank">Email</a> ¬∑ 
        <a href="https://twitter.com/tiborbodecs" target="_blank">Twitter</a> ¬∑ 
        <a href="https://github.com/tib" target="_blank">GitHub</a> 
    </div>
</section>

        
    </main>

    <footer>
        <section class="content-wrapper">
            <img 
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >

            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p> 
                <a href="https://theswiftdev.com/">Home</a> ¬∑
                <a href="https://theswiftdev.com/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="https://theswiftdev.com/sitemap.xml" target="_blank">Sitemap</a>
            </p>
            
            <p class="small">Created by Tibor B√∂decs &copy; 2015 - 2023.</p>
        </section>
    </footer>
</body>
</html>
