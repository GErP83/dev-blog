<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>How to download files with URLSession using Combine Publishers and Subscribers? - The.Swift.Dev.</title>
    
    <meta name="description" content="Learn how to load a remote image into an UIImageView asynchronously using URLSessionDownloadTask and the Combine framework in Swift.">
    
    <meta property="og:title" content="How to download files with URLSession using Combine Publishers and Subscribers? - The.Swift.Dev.">
    <meta property="og:description" content="Learn how to load a remote image into an UIImageView asynchronously using URLSessionDownloadTask and the Combine framework in Swift.">
    <meta property="og:url" content="https://theswiftdev.com/how-to-download-files-with-urlsession-using-combine-publishers-and-subscribers/">
    <meta property="og:image" content="https://theswiftdev.com/images/assets/how-to-download-files-with-urlsession-using-combine-publishers-and-subscribers/cover.jpg">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@tiborbodecs">
    <meta name="twitter:creator" content="@tiborbodecs">
    <meta name="twitter:title" content="How to download files with URLSession using Combine Publishers and Subscribers? - The.Swift.Dev.">
    <meta name="twitter:description" content="Learn how to load a remote image into an UIImageView asynchronously using URLSessionDownloadTask and the Combine framework in Swift.">
    <meta name="twitter:image" content="https://theswiftdev.com/images/assets/how-to-download-files-with-urlsession-using-combine-publishers-and-subscribers/cover.jpg">
    
    <link rel="stylesheet" href="https://theswiftdev.com/css/style.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/syntax.css">
    
    <link rel="mask-icon" sizes="any" href="https://theswiftdev.com/images/icons/icon.svg">

    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="https://theswiftdev.com/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="https://theswiftdev.com/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://theswiftdev.com/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://theswiftdev.com/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://theswiftdev.com/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://theswiftdev.com/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://theswiftdev.com/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://theswiftdev.com/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://theswiftdev.com/images/icons/apple-touch-icon-180x180.png">
    
</head>

<body>
    <a href="https://theswiftdev.gumroad.com" class="ribbon">
        üìñ
    </a>
    <header id="page-header">
        <a href="https://theswiftdev.com/">
            <img 
                id="logo-image"
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >
        </a>
    </header>
    
    <main>

        <article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2020/01/28">2020/01/28</time>
            <h1 class="title">How to download files with URLSession using Combine Publishers and Subscribers?</h1>
            <p class="excerpt">Learn how to load a remote image into an UIImageView asynchronously using URLSessionDownloadTask and the Combine framework in Swift.</p>
            <div class="meta">
                <span class="tag">URLSession</span>
<span class="tag">Combine</span>
            </div>
        </section>
        <section class="wrapper">
            <img id="post-image" src="https://theswiftdev.com/images/assets/how-to-download-files-with-urlsession-using-combine-publishers-and-subscribers/cover.jpg">
        </section>
    </header>

    <div id="contents">
        <section class="content-wrapper">
            <h2>A simple image downloader</h2><p>Downloading a resource from an URL seems like a trivial task, but is it really that easy? Well, it depends. If you have to <a href="https://theswiftdev.com/2018/01/29/how-to-parse-json-in-swift-using-codable-protocol/">download and parse a JSON file</a> which is just a few KB, then you can go with the classical way or you can use the new <code>dataTaskPublisher</code> method on the <a href="https://theswiftdev.com/2019/08/15/urlsession-and-the-combine-framework/">URLSession object from the Combine framework</a>.</p><h3>Bad practices ‚ö†Ô∏è</h3><p>There are some quick &amp; dirty approaches that you can use to get some smaller data from the internet. The problem with these methods is that you have to deal a lot with threads and queues. Fortunately <a href="https://theswiftdev.com/2018/07/10/ultimate-grand-central-dispatch-tutorial-in-swift/">using the Dispatch framework</a> helps a lot, so you can turn your blocking functions into non-blocking ones. üöß</p><pre><code class="language-swift"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://jsonplaceholder.typicode.com/todos/1"</span>)!

<span class="comment">// Synchronous download using Data &amp; String</span>
<span class="keyword">do</span> {
    <span class="comment">// get the content as String synchronously</span>
    <span class="keyword">let</span> content = <span class="keyword">try</span> <span class="type">String</span>(contentsOf: url)
    <span class="call">print</span>(content)

    <span class="comment">// get the content of the url as Data synchronously</span>
    <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: url)
}
<span class="keyword">catch</span> {
    <span class="call">print</span>(error.<span class="property">localizedDescription</span>)
}


<span class="comment">// Turning sync to async</span>
<span class="type">DispatchQueue</span>.<span class="call">global</span>().<span class="call">async</span> { [<span class="keyword">weak self</span>] <span class="keyword">in</span>
    <span class="comment">//this is happening on a background thread</span>
    <span class="keyword">do</span> {
        <span class="keyword">let</span> content = <span class="keyword">try</span> <span class="type">String</span>(contentsOf: url)
        <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
            <span class="comment">//this is happening on the main thread</span>
            <span class="call">print</span>(content)
        }
    }
    <span class="keyword">catch</span> {
        <span class="call">print</span>(error.<span class="property">localizedDescription</span>)
    }
}</code></pre><p>Apple made an important note on their <a href="https://developer.apple.com/documentation/foundation/nsdata/1547245-datawithcontentsofurl" target="_blank">official Data documentation</a>, that you should NOT use these methods for downloading non-file URLs, but still people are teaching / using these bad practices, but why? üò•</p><blockquote><p>Don't use this synchronous method to request network-based URLs.</p></blockquote><p>My advice here: always use the <a href="https://developer.apple.com/documentation/foundation/urlsession" target="_blank">URLSession</a> to perform network related data-transfers. Creating a data task is simple, it's an asynchronous operation by default, the callback runs on a background thread, so nothing will be blocked by default. Modern networking APIs are real good on iOS, in 99% of the cases you won't need <a href="https://github.com/alamofire/alamofire" target="_blank">Alamofire</a> anymore for these kind of tasks. Say no to dependencies! üö´</p><pre><code class="language-swift"><span class="comment">// The best approach without using Combine</span>
<span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">dataTask</span>(with: url) { data, response, error <span class="keyword">in</span>
    <span class="comment">// do your stuff here...</span>
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        <span class="comment">// do something on the main queue</span>
    }
}.<span class="call">resume</span>()</code></pre><p>It's also worth to mention if you need to use a different HTTP method (other than GET), send special headers (credentials, accept policies, etc.) or provide extra data in the body, you need to construct an <code>URLRequest</code> object first. You can only send these custom requests using the <code>URLSession</code> APIs.</p><p class="note">On Apple platforms you are not allowed to use the insecure HTTP protocol anymore. If you want to reach a URL without the secure layer (HTTPS) you have to disable <a href="https://developer.apple.com/security/" target="_blank">App Transport Security</a>.</p><h2>The problem with data tasks</h2><p>What about big files, such as images? Let me show you a few tutorials before we dive in:</p><ul><li><a href="https://stackoverflow.com/questions/47030822/uiimageview-load-uiimage-from-remote-url" target="_blank">UIImageView, Load UIImage from remote URL</a></li><li><a href="https://stackoverflow.com/questions/9786018/loading-an-image-into-uiimage-asynchronously" target="_blank">Loading an image into UIImage asynchronously</a></li><li><a href="https://www.hackingwithswift.com/example-code/uikit/how-to-load-a-remote-image-url-into-uiimageview" target="_blank">How to load a remote image URL into UIImageView</a></li><li><a href="https://iosdevcenters.blogspot.com/2018/06/how-to-downloading-image-from-server.html" target="_blank">How To Downloading Image from server URL on Swift 4?</a></li><li><a href="https://stackoverflow.com/questions/46199203/downloading-uiimage-via-alamofireimage" target="_blank">Downloading UIImage via AlamofireImage?</a></li><li><a href="https://medium.com/swlh/loading-images-from-url-in-swift-2bf8b9db266" target="_blank">Loading images from URL in Swift</a></li><li><a href="https://www.tutorialspoint.com/how-do-i-load-an-image-by-url-on-ios-device-using-swift" target="_blank">How do I load an image by URL on iOS device using Swift?</a></li><li><a href="http://swiftdeveloperblog.com/code-examples/uiimageview-and-uiimage-load-image-from-remote-url/" target="_blank">UIImageView and UIImage. Load Image From Remote URL.</a></li><li><a href="https://www.youtube.com/watch?v=DnZvlanmpNE" target="_blank">Asynchronously Loading Images in SwiftUI</a></li><li><a href="https://onmyway133.github.io/blog/How-to-load-remote-image-in-SwiftUI/" target="_blank">How to load remote image in SwiftUI</a></li><li><a href="https://stackoverflow.com/questions/24231680/loading-downloading-image-from-url-on-swift" target="_blank">Loading/Downloading image from URL on Swift</a></li></ul><p>With all due respect, I think all of these links above are really bad examples of loading remote images. Sure they do the job, they're also very easy to implement, but maybe we should cover the whole story... ü§ê</p><blockquote><p>For small interactions with remote servers, you can use the URLSessionDataTask class to receive response data into memory (as opposed to using the URLSessionDownloadTask class, which stores the data directly to the file system). A data task is ideal for uses like calling a web service endpoint.</p></blockquote><p>What is difference between <code>URLSessionDataTask</code> vs <code>URLSessionDownloadTask</code>?</p><p>If we <a href="https://developer.apple.com/documentation/foundation/url_loading_system/fetching_website_data_into_memory#overview" target="_blank">read the docs carefully</a>, it becomes clear that data task is NOT the right candidate for downloading big assets. That class is designed to request only smaller objects, since the underlying data is going to be loaded into memory. On the other hand the download task saves the content of the response on the disk (instead of memory) and you will receive a local file URL instead of a Data object. Turns out that moving from data tasks to download tasks will have a HUGE impact on your memory consumption. I have some numbers. üìà</p><p>I downloaded the <a href="https://images.unsplash.com/photo-1554773228-1f38662139db" target="_blank">following image file</a> (6000x4000px üíæ 13,1MB) using both methods. I made a brand new storyboard based Swift 5.1 project. The basic RAM usage was ~52MB, when I fetched the image using the <code>URLSessionDataTask</code> class, the memory usage jumped to ~82MB. Turning the data task into a download task only increased the base memory size by ~4MB (to a total ~56MB), which is a significant improvement.</p><pre><code class="language-swift"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://images.unsplash.com/photo-1554773228-1f38662139db"</span>)!

<span class="comment">// data task</span>
<span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">dataTask</span>(with: url) { [<span class="keyword">weak self</span>] data, response, error <span class="keyword">in
    guard let</span> data = data <span class="keyword">else</span> {
        <span class="keyword">return</span>
    }
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        <span class="keyword">self</span>?.<span class="property">imageView</span>.<span class="property">image</span> = <span class="type">UIImage</span>(data: data)
    }
}.<span class="call">resume</span>()


<span class="comment">// download task</span>
<span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">downloadTask</span>(with: url) { [<span class="keyword">weak self</span>] url, response, error <span class="keyword">in
    guard
        let</span> cache = <span class="type">FileManager</span>.<span class="property">default</span>.<span class="call">urls</span>(for: .<span class="dotAccess">cachesDirectory</span>, in: .<span class="dotAccess">userDomainMask</span>).<span class="property">first</span>,
        <span class="keyword">let</span> url = url
    <span class="keyword">else</span> {
        <span class="keyword">return</span>
    }

    <span class="keyword">do</span> {
        <span class="keyword">let</span> file = cache.<span class="call">appendingPathComponent</span>(<span class="string">"</span>\(<span class="type">UUID</span>().<span class="property">uuidString</span>)<span class="string">.jpg"</span>)
        <span class="keyword">try</span> <span class="type">FileManager</span>.<span class="property">default</span>.<span class="call">moveItem</span>(atPath: url.<span class="property">path</span>,
                                         toPath: file.<span class="property">path</span>)
        <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
            <span class="keyword">self</span>?.<span class="property">imageView</span>.<span class="property">image</span> = <span class="type">UIImage</span>(contentsOfFile: file.<span class="property">path</span>)
        }
    }
    <span class="keyword">catch</span> {
        <span class="call">print</span>(error.<span class="property">localizedDescription</span>)
    }
}.<span class="call">resume</span>()</code></pre><p>When I rendered the image using an <code>UIImageView</code> the memory footprint was ~118MB (total: ~170MB) for the data task, and ~93MB (total: ~145MB) for the download task. Here's a quick summary:</p><ul><li>Data task: ~30MB</li><li>Data task with rendering: ~118MB</li><li>Download task: ~4MB</li><li>Download task with rendering: ~93MB</li></ul><p>I hope you get my point. Please don't forget that the Foundation networking layer comes with four types of session tasks. You should always use the right one that fits the job. We can say that the <a href="https://stackoverflow.com/questions/20604910/what-is-difference-between-nsurlsessiondatatask-vs-nsurlsessiondownloadtask" target="_blank">difference between URLSessionDataTask vs URLSessionDownloadTask</a> is: a lot of memory (in this case about 25MB of RAM).</p><blockquote><p>You can use <a href="https://github.com/onevcat/Kingfisher" target="_blank">Kingfisher</a> or <a href="https://github.com/SDWebImage/SDWebImage" target="_blank">SDWebImage</a> to download &amp; manipulate remote images..</p></blockquote><p>You might say that this is an edge case since most of the images (even HD ones) are maximum a few hundred kilobytes. Still, my takeaway here is that we can do better, and we should always do so if possible. ü§ì</p><h2>Downloading images using Combine</h2><p>WWDC19, Apple announced the Combine framework, which brings us a few new extensions for some Foundation objects. Modern times require modern APIs, right? If you are already familiar with the new SDK that's good, but if you don't know what the heck is this declarative functional reactive madness, you should read my <a href="https://theswiftdev.com/2019/10/31/the-ultimate-combine-framework-tutorial-in-swift/">comprehensive tutorial about the Combine framework</a>.</p><p>The first version of Combine shipped with a nice <code>dataTaskPublisher</code> extension method for the <code>URLSession</code> class. Wait, where are the others? No download task publisher? What should we do now? ü§î</p><h3>How to write a custom Publisher?</h3><p><a href="https://x.com/twannl" target="_blank">SwiftLee</a> has a nice <a href="https://www.avanderlee.com/swift/custom-combine-publisher/" target="_blank">tutorial</a> about Combine that can help you a lot with UIControl events. Another great read (even better than the first one) by <a href="https://x.com/donnywals" target="_blank">Donny Wals</a> is about <a href="https://www.donnywals.com/understanding-combines-publishers-and-subscribers/" target="_blank">understanding Publishers and Subscribers</a>. It's a really well-written article, you should definitely check this one, I highly recommend it. ü§òüèª</p><p>Now let's start creating our own <code>DownloadTaskPublisher</code>. If you command + click on the <code>dataTaskPublisher</code> method in Xcode, you can see the corresponding interface. There is also a <code>DataTaskPublisher</code> struct, right below. Based on that template we can create our own extension. There are two variants of the same data task method, we'll replicate this behavior. The other thing we need is a <code>DownloadTaskPublisher</code> struct, I'll show you the Swift code first, then we'll discuss the implementation details.</p><pre><code class="language-swift"><span class="keyword">extension</span> <span class="type">URLSession</span> {

    <span class="keyword">public func</span> downloadTaskPublisher(for url: <span class="type">URL</span>) -&gt; <span class="type">URLSession</span>.<span class="type">DownloadTaskPublisher</span> {
        <span class="keyword">self</span>.<span class="call">downloadTaskPublisher</span>(for: .<span class="keyword">init</span>(url: url))
    }

    <span class="keyword">public func</span> downloadTaskPublisher(for request: <span class="type">URLRequest</span>) -&gt; <span class="type">URLSession</span>.<span class="type">DownloadTaskPublisher</span> {
        .<span class="keyword">init</span>(request: request, session: <span class="keyword">self</span>)
    }

    <span class="keyword">public struct</span> DownloadTaskPublisher: <span class="type">Publisher</span> {

        <span class="keyword">public typealias</span> Output = (url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>)
        <span class="keyword">public typealias</span> Failure = <span class="type">URLError</span>

        <span class="keyword">public let</span> request: <span class="type">URLRequest</span>
        <span class="keyword">public let</span> session: <span class="type">URLSession</span>

        <span class="keyword">public init</span>(request: <span class="type">URLRequest</span>, session: <span class="type">URLSession</span>) {
            <span class="keyword">self</span>.<span class="property">request</span> = request
            <span class="keyword">self</span>.<span class="property">session</span> = session
        }

        <span class="keyword">public func</span> receive&lt;S&gt;(subscriber: <span class="type">S</span>) <span class="keyword">where</span> <span class="type">S</span>: <span class="type">Subscriber</span>,
            DownloadTaskPublisher.<span class="type">Failure</span> == <span class="type">S</span>.<span class="type">Failure</span>,
            <span class="type">DownloadTaskPublisher</span>.<span class="type">Output</span> == <span class="type">S</span>.<span class="type">Input</span>
        {
            <span class="keyword">let</span> subscription = <span class="type">DownloadTaskSubscription</span>(subscriber: subscriber, session: <span class="keyword">self</span>.<span class="property">session</span>, request: <span class="keyword">self</span>.<span class="property">request</span>)
            subscriber.<span class="call">receive</span>(subscription: subscription)
        }
    }
}</code></pre><p>A Publisher can send an Output or a Failure message to an attached subscriber. You have to create a new typealias for each type, since they both are generic constraints defined on the protocol level. Next, we'll store the session and the request objects for later use. The last part of the protocol conformance is that you have to implement the <code>receive&lt;S&gt;(subscriber: S)</code> generic method. This method is responsible for attaching a new subscriber through a subscription object. Ummm... what? ü§®</p><blockquote><p>A publisher/subscriber relationship in Combine is solidified in a third object, the subscription. When a subscriber is created and subscribes to a publisher, the publisher will create a subscription object and it passes a reference to the subscription to the subscriber. The subscriber will then request a number of values from the subscription in order to begin receiving those values.</p></blockquote><p>A <code>Publisher</code> and a <code>Subscriber</code> is connected through a <code>Subscription</code>. The Publisher only creates the Subscription and passes it to the subscriber. The Subscription contains the logic that'll fetch new data for the Subscriber. The Subscriber receives the Subscription, the values and the completion (success or failure).</p><ul><li>The Subscriber subscribes to a Publisher</li><li>The Publisher creates a Subscription</li><li>The Publisher gives this Subscription to the Subscriber</li><li>The Subscriber demands some values from the Subscription</li><li>The Subscription tries to collect the values (success or failure)</li><li>The Subscription sends the values to the Subscriber based on the demand policy</li><li>The Subscription sends a Failure completion to the Subscriber if an error happens</li><li>The Subscription sends completion if no more values are available</li></ul><h3>How to make a custom Subscription?</h3><p>Ok, time to create our subscription for our little Combine based downloader, I think that you will understand the relationship between these three objects if we put together the final pieces of the code. üß©</p><pre><code class="language-swift"><span class="keyword">extension</span> <span class="type">URLSession</span> {

    <span class="keyword">final class</span> DownloadTaskSubscription&lt;SubscriberType: <span class="type">Subscriber</span>&gt;: <span class="type">Subscription</span> <span class="keyword">where</span>
        <span class="type">SubscriberType</span>.<span class="type">Input</span> == (url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>),
        <span class="type">SubscriberType</span>.<span class="type">Failure</span> == <span class="type">URLError</span>
    {
        <span class="keyword">private var</span> subscriber: <span class="type">SubscriberType</span>?
        <span class="keyword">private weak var</span> session: <span class="type">URLSession</span>!
        <span class="keyword">private var</span> request: <span class="type">URLRequest</span>!
        <span class="keyword">private var</span> task: <span class="type">URLSessionDownloadTask</span>!

        <span class="keyword">init</span>(subscriber: <span class="type">SubscriberType</span>, session: <span class="type">URLSession</span>, request: <span class="type">URLRequest</span>) {
            <span class="keyword">self</span>.<span class="property">subscriber</span> = subscriber
            <span class="keyword">self</span>.<span class="property">session</span> = session
            <span class="keyword">self</span>.<span class="property">request</span> = request
        }

        <span class="keyword">func</span> request(<span class="keyword">_</span> demand: <span class="type">Subscribers</span>.<span class="type">Demand</span>) {
            <span class="keyword">guard</span> demand &gt; <span class="number">0</span> <span class="keyword">else</span> {
                <span class="keyword">return</span>
            }
            <span class="keyword">self</span>.<span class="property">task</span> = <span class="keyword">self</span>.<span class="property">session</span>.<span class="call">downloadTask</span>(with: request) { [<span class="keyword">weak self</span>] url, response, error <span class="keyword">in
                if let</span> error = error <span class="keyword">as</span>? <span class="type">URLError</span> {
                    <span class="keyword">self</span>?.<span class="property">subscriber</span>?.<span class="call">receive</span>(completion: .<span class="call">failure</span>(error))
                    <span class="keyword">return</span>
                }
                <span class="keyword">guard let</span> response = response <span class="keyword">else</span> {
                    <span class="keyword">self</span>?.<span class="property">subscriber</span>?.<span class="call">receive</span>(completion: .<span class="call">failure</span>(<span class="type">URLError</span>(.<span class="dotAccess">badServerResponse</span>)))
                    <span class="keyword">return</span>
                }
                <span class="keyword">guard let</span> url = url <span class="keyword">else</span> {
                    <span class="keyword">self</span>?.<span class="property">subscriber</span>?.<span class="call">receive</span>(completion: .<span class="call">failure</span>(<span class="type">URLError</span>(.<span class="dotAccess">badURL</span>)))
                    <span class="keyword">return</span>
                }
                <span class="keyword">do</span> {
                    <span class="keyword">let</span> cacheDir = <span class="type">FileManager</span>.<span class="property">default</span>.<span class="call">urls</span>(for: .<span class="dotAccess">cachesDirectory</span>, in: .<span class="dotAccess">userDomainMask</span>).<span class="property">first</span>!
                    <span class="keyword">let</span> fileUrl = cacheDir.<span class="call">appendingPathComponent</span>((<span class="type">UUID</span>().<span class="property">uuidString</span>))
                    <span class="keyword">try</span> <span class="type">FileManager</span>.<span class="property">default</span>.<span class="call">moveItem</span>(atPath: url.<span class="property">path</span>, toPath: fileUrl.<span class="property">path</span>)
                    <span class="keyword">_</span> = <span class="keyword">self</span>?.<span class="property">subscriber</span>?.<span class="call">receive</span>((url: fileUrl, response: response))
                    <span class="keyword">self</span>?.<span class="property">subscriber</span>?.<span class="call">receive</span>(completion: .<span class="dotAccess">finished</span>)
                }
                <span class="keyword">catch</span> {
                    <span class="keyword">self</span>?.<span class="property">subscriber</span>?.<span class="call">receive</span>(completion: .<span class="call">failure</span>(<span class="type">URLError</span>(.<span class="dotAccess">cannotCreateFile</span>)))
                }
            }
            <span class="keyword">self</span>.<span class="property">task</span>.<span class="call">resume</span>()
        }

        <span class="keyword">func</span> cancel() {
            <span class="keyword">self</span>.<span class="property">task</span>.<span class="call">cancel</span>()
        }
    }
}</code></pre><p>A Subscriber has an Input and a Failure type. A subscriber can only subscribe to a publisher with the same types. The Publisher's Output &amp; Failure types have to be identical with the Subscription Input and Failure types. This time we can't go with an associatedType, but we have to create a generic value that has a constraint on these requirements by using a where clause. The reason behind this is that we don't know what kind of Subscriber will subscribe to this subscription. It can be either a class <code>A</code> or <code>B</code>, who knows... ü§∑‚Äç‚ôÇÔ∏è</p><p>We have to pass a few properties in the init method, store them as instance variables (be careful with classes, you should use weak if applicable). Lastly we implement the value request method, by respecting the demand policy. The <a href="https://developer.apple.com/documentation/combine/subscribers/demand" target="_blank">demand</a> is just a number. It tells us how many values can we send back to the subscriber at maximum. In our case we'll have max 1 value, so if the demand is greater than zero, we're good to go. You can send messages to the subscriber by calling various receive methods on it.</p><p>You have to manually send the completion event with the <code>.finished</code> or the <code>.failure(T)</code> value. Also we have to move the downloaded temporary file before the completion block returns otherwise we'll completely lose it. This time I'm going to simply move the file to the application cache directory. As a gratis cancellation is a great way to end battery draining operations. You just need to implement a custom <code>cancel()</code> method. In our case, we can call the same method on the underlying <code>URLSessionDownloadTask</code>.</p><p>That's it. We're ready with the custom publisher &amp; subscription. Wanna try them out?</p><h3>How to create a custom Subscriber?</h3><p>Let's say that there are 4 kinds of subscriptions. You can use the <code>.sink</code> or the <code>.assign</code> method to make a new subscription, there is also a thing called Subject, which can be subscribed for publisher events or you can build your very own <code>Subscriber</code> object. If you choose this path you can use the <code>.subscribe</code> method to associate the publisher and the subscriber. You can also subscribe a subject.</p><pre><code class="language-swift"><span class="keyword">final class</span> DownloadTaskSubscriber: <span class="type">Subscriber</span> {
    <span class="keyword">typealias</span> Input = (url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>)
    <span class="keyword">typealias</span> Failure = <span class="type">URLError</span>

    <span class="keyword">var</span> subscription: <span class="type">Subscription</span>?

    <span class="keyword">func</span> receive(subscription: <span class="type">Subscription</span>) {
        <span class="keyword">self</span>.<span class="property">subscription</span> = subscription
        <span class="keyword">self</span>.<span class="property">subscription</span>?.<span class="call">request</span>(.<span class="dotAccess">unlimited</span>)
    }

    <span class="keyword">func</span> receive(<span class="keyword">_</span> input: <span class="type">Input</span>) -&gt; <span class="type">Subscribers</span>.<span class="type">Demand</span> {
        <span class="call">print</span>(<span class="string">"Subscriber value</span> \(input.<span class="property">url</span>)<span class="string">"</span>)
        <span class="keyword">return</span> .<span class="dotAccess">unlimited</span>
    }

    <span class="keyword">func</span> receive(completion: <span class="type">Subscribers</span>.<span class="type">Completion</span>&lt;<span class="type">Failure</span>&gt;) {
        <span class="call">print</span>(<span class="string">"Subscriber completion</span> \(completion)<span class="string">"</span>)
        <span class="keyword">self</span>.<span class="property">subscription</span>?.<span class="call">cancel</span>()
        <span class="keyword">self</span>.<span class="property">subscription</span> = <span class="keyword">nil</span>
    }
}</code></pre><p>The subscriber above will simply print out the incoming values. We have to be extremely careful with memory management. The received subscription will be stored as a strong property, but when the publisher sends a completion event we should cancel the subscription and remove the reference.</p><p>When a value arrives we have to return a demand. In our case it really doesn't matter since we'll only have 1 incoming value, but if you'd like to limit your publisher, you can use e.g. <code>.max(1)</code> as a demand.</p><p>Here is a quick sample code for all the Combine subscriber types written in Swift 5.1:</p><pre><code class="language-swift"><span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {

    <span class="keyword">@IBOutlet weak var</span> imageView: <span class="type">UIImageView</span>!

    <span class="keyword">static let</span> url = <span class="type">URL</span>(string: <span class="string">"https://images.unsplash.com/photo-1554773228-1f38662139db"</span>)!

    <span class="keyword">static var</span> defaultValue: (url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>) = {
        <span class="keyword">let</span> fallbackUrl = <span class="type">URL</span>(fileURLWithPath: <span class="string">"fallback-image-path"</span>)
        <span class="keyword">let</span> fallbackResponse = <span class="type">URLResponse</span>(url: fallbackUrl, mimeType: <span class="string">"foo"</span>, expectedContentLength: <span class="number">1</span>, textEncodingName: <span class="string">"bar"</span>)
        <span class="keyword">return</span> (url: fallbackUrl, response: fallbackResponse)
    }()

    <span class="keyword">@Published var</span> value: (url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>) = <span class="type">ViewController</span>.<span class="property">defaultValue</span>
    <span class="keyword">let</span> subject = <span class="type">PassthroughSubject</span>&lt;(url: <span class="type">URL</span>, response: <span class="type">URLResponse</span>), <span class="type">URLError</span>&gt;()
    <span class="keyword">let</span> subscriber = <span class="type">DownloadTaskSubscriber</span>()

    <span class="keyword">var</span> sinkOperation: <span class="type">AnyCancellable</span>?

    <span class="keyword">var</span> assignOperation: <span class="type">AnyCancellable</span>?
    <span class="keyword">var</span> assignSinkOperation: <span class="type">AnyCancellable</span>?

    <span class="keyword">var</span> subjectOperation: <span class="type">AnyCancellable</span>?
    <span class="keyword">var</span> subjectSinkOperation: <span class="type">AnyCancellable</span>?

    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()

        <span class="keyword">self</span>.<span class="call">sinkExample</span>()
        <span class="keyword">self</span>.<span class="call">assignExample</span>()
        <span class="keyword">self</span>.<span class="call">subjectExample</span>()
        <span class="keyword">self</span>.<span class="call">subscriberExample</span>()
    }

    <span class="keyword">func</span> sinkExample() {
        <span class="keyword">self</span>.<span class="property">sinkOperation</span> = <span class="type">URLSession</span>.<span class="property">shared</span>
            .<span class="call">downloadTaskPublisher</span>(for: <span class="type">ViewController</span>.<span class="property">url</span>)
            .<span class="call">sink</span>(receiveCompletion: { completion <span class="keyword">in</span>
                <span class="call">print</span>(<span class="string">"Sink completion:</span> \(completion)<span class="string">"</span>)
            }) { value <span class="keyword">in</span>
                <span class="call">print</span>(<span class="string">"Sink value:</span> \(value.<span class="property">url</span>)<span class="string">"</span>)
            }
    }

    <span class="keyword">func</span> assignExample() {
        <span class="keyword">self</span>.<span class="property">assignSinkOperation</span> = <span class="keyword">self</span>.<span class="property">$value</span>.<span class="call">sink</span> { value <span class="keyword">in</span>
            <span class="call">print</span>(<span class="string">"Assign value:</span> \(value.<span class="property">url</span>)<span class="string">"</span>)
        }

        <span class="keyword">self</span>.<span class="property">assignOperation</span> = <span class="type">URLSession</span>.<span class="property">shared</span>
            .<span class="call">downloadTaskPublisher</span>(for: <span class="type">ViewController</span>.<span class="property">url</span>)
            .<span class="call">replaceError</span>(with: <span class="type">ViewController</span>.<span class="property">defaultValue</span>)
            .<span class="call">assign</span>(to: \.<span class="property">value</span>, on: <span class="keyword">self</span>)
    }

    <span class="keyword">func</span> subjectExample() {
        <span class="keyword">self</span>.<span class="property">subjectSinkOperation</span> = <span class="keyword">self</span>.<span class="property">subject</span>.<span class="call">sink</span>(receiveCompletion: { completion <span class="keyword">in</span>
            <span class="call">print</span>(<span class="string">"Subject completion:</span> \(completion)<span class="string">"</span>)
        }) { value <span class="keyword">in</span>
            <span class="call">print</span>(<span class="string">"Subject value:</span> \(value.<span class="property">url</span>)<span class="string">"</span>)
        }

        <span class="keyword">self</span>.<span class="property">subjectOperation</span> = <span class="type">URLSession</span>.<span class="property">shared</span>
            .<span class="call">downloadTaskPublisher</span>(for: <span class="type">ViewController</span>.<span class="property">url</span>)
            .<span class="call">subscribe</span>(<span class="keyword">self</span>.<span class="property">subject</span>)
    }

    <span class="keyword">func</span> subscriberExample() {
        <span class="type">URLSession</span>.<span class="property">shared</span>
            .<span class="call">downloadTaskPublisher</span>(for: <span class="type">ViewController</span>.<span class="property">url</span>)
            .<span class="call">subscribe</span>(<span class="type">DownloadTaskSubscriber</span>())
    }
}</code></pre><p>This is really nice. We can download a file using our custom Combine based URLSession extension.</p><p class="note">Don't forget to store the AnyCancellable pointer otherwise the entire Combine operation will be deallocated way before you could receive anything from the chain / stream.</p><h2>Putting everything together</h2><p>I promised a working image downloader, so let me explain the whole flow. We have a custom download task publisher that'll save our remove image file locally and returns a tuple with the file URL and the response. ‚úÖ</p><p>Next I'm going to simply assume that there was a valid image behind the URL, and the server returned a valid response, so I'm going to map the publisher's output to an <code>UIImage</code> object. I'm also going to replace any kind of error with a fallback image value. In a real-world application, you should always do some extra checkings on the <code>URLResponse</code> object, but for the sake of simplicity I'll skip that for now.</p><p>The last thing is to update our image view with the returned image. Since this is a UI task it should happen on the main thread, so we have to use the <code>receive(on:)</code> operation to switch context. If you want to learn more about <a href="https://www.vadimbulavin.com/understanding-schedulers-in-swift-combine-framework/" target="_blank">schedulers in the Combine framework</a> you should read <a href="https://x.com/v8tr" target="_blank">Vadim Bulavin's article</a>. It's a gem. üíé</p><p class="warning">If you are not receiving values on certain appleOS versions, that's might because there was a change in Combine around December, 2019. You should check these links: <a href="https://forums.swift.org/t/combine-receive-on-runloop-main-loses-sent-value-how-can-i-make-it-work/28631/47" target="_blank">link1</a>, <a href="https://heckj.github.io/swiftui-notes/#coreconcepts-lifecycle" target="_blank">link2</a></p><p>Anyway, here's the final Swift code for a possible image download operation, simple &amp; declarative. üëç</p><pre><code class="language-swift"><span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {

    <span class="keyword">@IBOutlet weak var</span> imageView: <span class="type">UIImageView</span>!

    <span class="keyword">var</span> operation: <span class="type">AnyCancellable</span>?

    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()

        <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://images.unsplash.com/photo-1554773228-1f38662139db"</span>)!

        <span class="keyword">self</span>.<span class="property">operation</span> = <span class="type">URLSession</span>.<span class="property">shared</span>
            .<span class="call">downloadTaskPublisher</span>(for: url)
            .<span class="call">map</span> { <span class="type">UIImage</span>(contentsOfFile: $0.<span class="property">url</span>.<span class="property">path</span>)! }
            .<span class="call">replaceError</span>(with: <span class="type">UIImage</span>(named: <span class="string">"fallback"</span>))
            .<span class="call">receive</span>(on: <span class="type">DispatchQueue</span>.<span class="property">main</span>)
            .<span class="call">assign</span>(to: \.<span class="property">image</span>, on: <span class="keyword">self</span>.<span class="property">imageView</span>)
    }
}</code></pre><p>Finally, we can display our image. Ouch, but wait... there is still room for improvements. What about <a href="https://www.appsdissected.com/caching-custom-combine-operator-2-cache-method-generics/" target="_blank">caching</a>? Plus a 6000x4000px picture is quite huge for a small display, shouldn't we <a href="https://stackoverflow.com/questions/31314412/how-to-resize-image-in-swift" target="_blank">resize / scale the image</a> first? What happens if I want to use the image in a list, shouldn't I cancel the download tasks when the user scrolls? üò≥</p><p>Maybe I'll write about these issues in an upcoming tutorial, but I think this is the point where I should end this article. Feel free to play around with my solution and please share your ideas &amp; thoughts with me on Twitter.</p>
        </section>
    </div>

</article>

<section id="share" class="content-wrapper">
    <p>
    <a
        href="https://x.com/intent/tweet?via=tiborbodecs&amp;hashtags=SwiftLang&amp;url=https://theswiftdev.com/how-to-download-files-with-urlsession-using-combine-publishers-and-subscribers/"
        target="_blank"
    >
        Share this article
    </a>
    <br> Thank you. üôè</p>
</section>

<section  class="wrapper">
    <div id="book">
        <div class="column left">
            <img src="https://theswiftdev.com/images/practical-server-side-swift-cover.png">
        </div>
        <div class="column right">
            <h3>Get the Practical Server Side Swift book</h3>
            <p>Swift on the server is an amazing new opportunity to build fast, safe and scalable backend apps. Write your very first web-based application by using your favorite programming language. Learn how to build a modular blog engine using the latest version of the Vapor 4 framework. This book will help you to design and create modern APIs that'll allow you to share code between the server side and iOS. Start becoming a full-stack Swift developer.</p>
            <a class="button" href="https://gumroad.com/l/practical-server-side-swift" target="_blank">Available on Gumroad</a>
        </div>
    </div>
</section>

<section id="author" class="content-wrapper">
    <img 
        id="author-image"
        src="https://theswiftdev.com/images/profiles/tiborbodecs.jpg"
        alt="Picture of Tibor B√∂decs" 
        title="Tibor B√∂decs"
    >
    <h3>Tibor B√∂decs</h3>
    <p class="title">CEO @ <a href="https://binarybirds.com/">Binary Birds</a></p>
    <p class="bio">Server side Swift enthusiast, book author, content creator.</p>

    <div class="links">
        <a href="mailto:mail.tib@gmail.com?subject=theswiftdev.com" target="_blank">Email</a> ¬∑ 
        <a href="https://x.com/tiborbodecs" target="_blank">X</a> ¬∑ 
        <a href="https://github.com/tib" target="_blank">GitHub</a> 
    </div>
</section>

        
    </main>

    <footer>
        <section class="content-wrapper">
            <img 
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >

            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p> 
                <a href="https://theswiftdev.com/">Home</a> ¬∑
                <a href="https://theswiftdev.com/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="https://theswiftdev.com/sitemap.xml" target="_blank">Sitemap</a>
            </p>
            
            <p class="small">Created by Tibor B√∂decs &copy; 2015 - 2023.</p>
        </section>
    </footer>
</body>
</html>
