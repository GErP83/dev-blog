<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Ultimate Grand Central Dispatch tutorial in Swift - The.Swift.Dev.</title>
    
    <meta name="description" content="Learn the principles of multi-threading with the GCD framework in Swift. Queues, tasks, groups everything you'll ever need I promise.">
    
    <meta property="og:title" content="Ultimate Grand Central Dispatch tutorial in Swift - The.Swift.Dev.">
    <meta property="og:description" content="Learn the principles of multi-threading with the GCD framework in Swift. Queues, tasks, groups everything you'll ever need I promise.">
    <meta property="og:url" content="https://theswiftdev.com/ultimate-grand-central-dispatch-tutorial-in-swift">
    <meta property="og:image" content="https://theswiftdev.com/images/assets/ultimate-grand-central-dispatch-tutorial-in-swift/cover.jpg">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@tiborbodecs">
    <meta name="twitter:creator" content="@tiborbodecs">
    <meta name="twitter:title" content="Ultimate Grand Central Dispatch tutorial in Swift - The.Swift.Dev.">
    <meta name="twitter:description" content="Learn the principles of multi-threading with the GCD framework in Swift. Queues, tasks, groups everything you'll ever need I promise.">
    <meta name="twitter:image" content="https://theswiftdev.com/images/assets/ultimate-grand-central-dispatch-tutorial-in-swift/cover.jpg">
    
    <link rel="stylesheet" href="https://theswiftdev.com/css/style.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/syntax.css">
    
    <link rel="mask-icon" sizes="any" href="https://theswiftdev.com/images/icons/icon.svg">

    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="https://theswiftdev.com/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="https://theswiftdev.com/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://theswiftdev.com/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://theswiftdev.com/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://theswiftdev.com/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://theswiftdev.com/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://theswiftdev.com/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://theswiftdev.com/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://theswiftdev.com/images/icons/apple-touch-icon-180x180.png">
    
</head>

<body>
    <a href="https://theswiftdev.gumroad.com" class="ribbon">
        üìñ
    </a>
    <header id="page-header">
        <a href="https://theswiftdev.com/">
            <img 
                id="logo-image"
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >
        </a>
    </header>
    
    <main>

        <article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2018/07/10">2018/07/10</time>
            <h1 class="title">Ultimate Grand Central Dispatch tutorial in Swift</h1>
            <p class="excerpt">Learn the principles of multi-threading with the GCD framework in Swift. Queues, tasks, groups everything you'll ever need I promise.</p>
            <div class="meta">
                <span class="tag">Swift</span>
<span class="tag">Dispatch</span>
<span class="tag">Queues</span>
<span class="tag">Concurrency</span>
            </div>
        </section>
        <section class="wrapper">
            <img id="post-image" src="https://theswiftdev.com/images/assets/ultimate-grand-central-dispatch-tutorial-in-swift/cover.jpg">
        </section>
    </header>

    <div id="contents">
        <section class="content-wrapper">
            <h2>GCD concurrency tutorial for beginners</h2><p>The <a href="https://developer.apple.com/documentation/dispatch" target="_blank">Grand Central Dispatch</a> (GCD, or just Dispatch) framework is based on the underlying thread pool design pattern. This means that there are a fixed number of threads spawned by the system - based on some factors like CPU cores - they're always available waiting for tasks to be executed concurrently. üö¶</p><p>Creating threads on the run is an expensive task so <a href="https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1" target="_blank">GCD</a> organizes tasks into specific queues, and later on the tasks waiting on these queues are going to be executed on a proper and available thread from the pool. This approach leads to great performance and low execution latency. We can say that the <a href="https://www.swiftbysundell.com/posts/a-deep-dive-into-grand-central-dispatch-in-swift" target="_blank">Dispatch</a> framework is a very fast and efficient concurrency framework designed for modern multi-core hardware and needs.</p><h3>Concurrency, multi-tasking, CPU cores, parallelism and threads</h3><p>A processor can run tasks made by you programmatically, this is usually called coding, developing or programming. The code executed by a <a href="https://www.quora.com/What-is-the-difference-between-cores-and-threads-of-a-processor" target="_blank">CPU core</a> is a thread. So your app is going to create a process that is made up from threads. ü§ì</p><p>In the past a processor had one single core, it could only deal with one task at a time. Later on time-slicing was introduced, so CPU's could execute threads concurrently using context switching. As time passed by processors gained more horse power and cores so they were capable of real multi-tasking using parallelism. ‚è±</p><p>Nowadays a CPU is a very powerful unit, it's capable of executing billions of tasks (cycles) per second. Because of this high availability speed Intel introduced a technology called hyper-threading. They divided CPU clock cycles between (usually two) processes running at the same time, so the number of available threads essentially doubled. üìà</p><p>As you can see concurrent execution can be achieved with various techniques, but you don't need to care about that much. It's up to the CPU architecture how it solves <a href="https://www.uraimo.com/2017/05/07/all-about-concurrency-in-swift-1-the-present/" target="_blank">concurrency</a>, and it's the operating system's task how much thread is going to be spawned for the underlying thread pool. The GCD framework will hide all the complexity, but it's always good to understand the basic principles. üëç</p><h2>Synchronous and asynchronous execution</h2><p>Each work item can be executed either synchronously or asynchronously.</p><p>Have you ever heard of blocking and non-blocking code? This is the same situation here. With synchronous tasks you'll block the execution queue, but with async tasks your call will instantly return and the queue can continue the execution of the remaining tasks (or work items as Apple calls them). üöß</p><h3>Synchronous execution</h3><p>When a work item is executed synchronously with the sync method, the program waits until execution finishes before the method call returns.</p><p>Your function is most likely synchronous if it has a return value, so <code>func load() -&gt; String</code> is going to probably block the thing that runs on until the resources is completely loaded and returned back.</p><h3>Asynchronous execution</h3><p>When a work item is executed asynchronously with the async method, the method call returns immediately.</p><p>Completion blocks are a good sing of async methods, for example if you look at this method <code>func load(completion: (String) -&gt; Void)</code> you can see that it has no return type, but the result of the function is passed back to the caller later on through a block.</p><p>This is a typical use case, if you have to wait for something inside your method like reading the contents of a huge file from the disk, you don't want to block your CPU, just because of the slow IO operation. There can be other tasks that are not IO heavy at all (math operations, etc.) those can be executed while the system is reading your file from the physical hard drive. üíæ</p><p>With dispatch queues you can execute your code synchronously or asynchronously. With synchronous execution the queue waits for the work, with async execution the code returns immediately without waiting for the task to complete. ‚ö°Ô∏è</p><h2>Dispatch queues</h2><p>As I mentioned before, <a href="https://www.appcoda.com/grand-central-dispatch/" target="_blank">GCD</a> organizes task into queues, these are just like the queues at the shopping mall. On every dispatch queue, tasks will be executed in the same order as you add them to the queue - FIFO: the first task in the line will be executed first - but you should note that the order of completion is not guaranteed. Tasks will be completed according to the code complexity. So if you add two tasks to the queue, a slow one first and a fast one later, the fast one can finish before the slower one. ‚åõÔ∏è</p><h3>Serial and concurrent queues</h3><p>There are two types of dispatch queues. Serial queues can execute one task at a time, these queues can be utilized to synchronize access to a specific resource. Concurrent queues on the other hand can execute one or more tasks parallel in the same time. Serial queue is just like one line in the mall with one cashier, concurrent queue is like one single line that splits for two or more cashiers. üí∞</p><h3>Main, global and custom queues</h3><p>The main queue is a serial one, every task on the main queue runs on the main thread.</p><p>Global queues are system provided concurrent queues shared through the operating system. There are exactly four of them organized by high, default, low priority plus an IO throttled background queue.</p><p>Custom queues can be created by the user. Custom concurrent queues always mapped into one of the global queues by specifying a Quality of Service property (QoS). In most of the cases if you want to run tasks in parallel it is recommended to use one of the global concurrent queues, you should only create custom serial queues.</p><h3>System provided queues</h3><ul><li>Serial main queue</li><li>Concurrent global queues</li><li>high priority global queue</li><li>default priority global queue</li><li>low priority global queue</li><li>global background queue (IO throttled)</li></ul><h3>Custom queues by quality of service</h3><ul><li>userInteractive (UI updates) -&gt; serial main queue</li><li>userInitiated (async UI related tasks) -&gt; high priority global queue</li><li>default -&gt; default priority global queue</li><li>utility -&gt; low priority global queue</li><li>background -&gt; global background queue</li><li>unspecified (lowest) -&gt; low priority global queue</li></ul><p>Enough from the theory, let's see how to use the Dispatch framework in action! üé¨</p><h2>How to use the DispatchQueue class in Swift?</h2><p>Here is how you can get all the queues from above using the brand new GCD syntax available from Swift 3. Please note that you should always use a global concurrent queue instead of creating your own one, except if you are going to use the concurrent queue for locking with barriers to achieve <a href="http://basememara.com/creating-thread-safe-arrays-in-swift/" target="_blank">thread safety</a>, more on that later. üò≥</p><h3>How to get a queue?</h3><pre><code class="language-swift"><span class="keyword">import</span> Dispatch

<span class="type">DispatchQueue</span>.<span class="property">main</span>
<span class="type">DispatchQueue</span>.<span class="call">global</span>(qos: .<span class="dotAccess">userInitiated</span>)
<span class="type">DispatchQueue</span>.<span class="call">global</span>(qos: .<span class="dotAccess">userInteractive</span>)
<span class="type">DispatchQueue</span>.<span class="call">global</span>(qos: .<span class="dotAccess">background</span>)
<span class="type">DispatchQueue</span>.<span class="call">global</span>(qos: .<span class="dotAccess">default</span>)
<span class="type">DispatchQueue</span>.<span class="call">global</span>(qos: .<span class="dotAccess">utility</span>)
<span class="type">DispatchQueue</span>.<span class="call">global</span>(qos: .<span class="dotAccess">unspecified</span>)

<span class="type">DispatchQueue</span>(
    label: <span class="string">"com.theswiftdev.queues.serial"</span>
)

<span class="type">DispatchQueue</span>(
    label: <span class="string">"com.theswiftdev.queues.concurrent"</span>, 
    attributes: .<span class="dotAccess">concurrent</span>
)</code></pre><p>So executing a task on a background queue and updating the UI on the main queue after the task finished is a pretty easy one using Dispatch queues.</p><pre><code class="language-swift"><span class="type">DispatchQueue</span>.<span class="call">global</span>(qos: .<span class="dotAccess">background</span>).<span class="call">async</span> {
    <span class="comment">// do your job here</span>

    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        <span class="comment">// update ui here</span>
    }
}</code></pre><h3>Sync and async calls on queues</h3><p>There is no big difference between sync and async methods on a queue. Sync is just an async call with a semaphore (explained later) that waits for the return value. A sync call will block, on the other hand an async call will immediately return. üéâ</p><pre><code class="language-swift"><span class="keyword">let</span> q = <span class="type">DispatchQueue</span>.<span class="call">global</span>()

<span class="keyword">let</span> text = q.<span class="call">sync</span> {
    <span class="keyword">return</span> <span class="string">"this will block"</span>
}
<span class="call">print</span>(text)

q.<span class="call">async</span> {
    <span class="call">print</span>(<span class="string">"this will return instantly"</span>)
}</code></pre><p>Basically if you need a return value use sync, but in every other case just go with async. DEADLOCK WARNING: you should never call sync on the main queue, because it'll cause a deadlock and a crash. You can use this <a href="https://gist.github.com/sgr-ksmt/4880c5df5aeec9e558622cd6d5b477cb" target="_blank">snippet</a> if you are looking for a safe way to do sync calls on the main queue / thread. üëå</p><blockquote><p>Don't call sync on a serial queue from the serial queue's thread!</p></blockquote><h3>Delay execution</h3><p>You can simply delay code execution using the Dispatch framework.</p><pre><code class="language-swift"><span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">asyncAfter</span>(deadline: .<span class="call">now</span>() + .<span class="call">seconds</span>(<span class="number">2</span>)) {
    <span class="comment">//this code will be executed only after 2 seconds have been passed</span>
}</code></pre><h3>Perform concurrent loop</h3><p>Dispatch queue simply allows you to perform iterations concurrently.</p><pre><code class="language-swift"><span class="type">DispatchQueue</span>.<span class="call">concurrentPerform</span>(iterations: <span class="number">5</span>) { (i) <span class="keyword">in</span>
    <span class="call">print</span>(i)
}</code></pre><h3>Debugging</h3><p>Oh, by the way it's just for debugging purpose, but you can return the name of the current queue by using this little extension. Do not use in production code!!!</p><pre><code class="language-swift"><span class="keyword">extension</span> <span class="type">DispatchQueue</span> {
    <span class="keyword">static var</span> currentLabel: <span class="type">String</span> {
        .<span class="keyword">init</span>(validatingUTF8: <span class="call">__dispatch_queue_get_label</span>(<span class="keyword">nil</span>))!
    }
}
<span class="comment">//print(DispatchQueue.currentLabel)</span></code></pre><h3>Using DispatchWorkItem in Swift</h3><blockquote><p>DispatchWorkItem encapsulates work that can be performed. A work item can be dispatched onto a DispatchQueue and within a DispatchGroup. A DispatchWorkItem can also be set as a DispatchSource event, registration, or cancel handler.</p></blockquote><p>So you just like with operations by using a work item you can cancel a running task. Also work items can notify a queue when their task is completed.</p><pre><code class="language-swift"><span class="keyword">var</span> workItem: <span class="type">DispatchWorkItem</span>?
workItem = <span class="type">DispatchWorkItem</span> {
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">6</span> {
        <span class="keyword">guard let</span> item = workItem, !item.<span class="property">isCancelled</span> <span class="keyword">else</span> {
            <span class="call">print</span>(<span class="string">"cancelled"</span>)
            <span class="keyword">break</span>
        }
        <span class="call">sleep</span>(<span class="number">1</span>)
        <span class="call">print</span>(<span class="type">String</span>(i))
    }
}

workItem?.<span class="call">notify</span>(queue: .<span class="dotAccess">main</span>) {
    <span class="call">print</span>(<span class="string">"done"</span>)
}


<span class="type">DispatchQueue</span>.<span class="call">global</span>().<span class="call">asyncAfter</span>(
    deadline: .<span class="call">now</span>() + .<span class="call">seconds</span>(<span class="number">2</span>)
) {
    workItem?.<span class="call">cancel</span>()
}
<span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span>(execute: workItem!)
<span class="comment">// you can use perform to run on the current queue instead of queue.async(execute:)
//workItem?.perform()</span></code></pre><h3>Concurrent tasks with DispatchGroups</h3><p>So you need to perform multiple network calls in order to construct the data required by a view controller? This is where DispatchGroup can help you. All of your long running background task can be executed concurrently, when everything is ready you'll receive a notification. Just be careful you have to use thread-safe data structures, so always modify arrays for example on the same thread! üòÖ</p><pre><code class="language-swift"><span class="keyword">func</span> load(delay: <span class="type">UInt32</span>, completion: () -&gt; <span class="type">Void</span>) {
    <span class="call">sleep</span>(delay)
    <span class="call">completion</span>()
}

<span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()

group.<span class="call">enter</span>()
<span class="call">load</span>(delay: <span class="number">1</span>) {
    <span class="call">print</span>(<span class="string">"1"</span>)
    group.<span class="call">leave</span>()
}

group.<span class="call">enter</span>()
<span class="call">load</span>(delay: <span class="number">2</span>) {
    <span class="call">print</span>(<span class="string">"2"</span>)
    group.<span class="call">leave</span>()
}

group.<span class="call">enter</span>()
<span class="call">load</span>(delay: <span class="number">3</span>) {
    <span class="call">print</span>(<span class="string">"3"</span>)
    group.<span class="call">leave</span>()
}

group.<span class="call">notify</span>(queue: .<span class="dotAccess">main</span>) {
    <span class="call">print</span>(<span class="string">"done"</span>)
}</code></pre><p>Note that you always have to balance out the enter and leave calls on the group. The dispatch group also allows us to track the completion of different work items, even if they run on different queues.</p><pre><code class="language-swift"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()
<span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(
    label: <span class="string">"com.theswiftdev.queues.serial"</span>
)
<span class="keyword">let</span> workItem = <span class="type">DispatchWorkItem</span> {
    <span class="call">print</span>(<span class="string">"start"</span>)
    <span class="call">sleep</span>(<span class="number">1</span>)
    <span class="call">print</span>(<span class="string">"end"</span>)
}

queue.<span class="call">async</span>(group: group) {
    <span class="call">print</span>(<span class="string">"group start"</span>)
    <span class="call">sleep</span>(<span class="number">2</span>)
    <span class="call">print</span>(<span class="string">"group end"</span>)
}
<span class="type">DispatchQueue</span>.<span class="call">global</span>().<span class="call">async</span>(
    group: group, 
    execute: workItem
)

<span class="comment">// you can block your current queue and wait until the group is ready
// a better way is to use a notification block instead of blocking
//group.wait(timeout: .now() + .seconds(3))
//print("done")</span>

group.<span class="call">notify</span>(queue: .<span class="dotAccess">main</span>) {
    <span class="call">print</span>(<span class="string">"done"</span>)
}</code></pre><p>One more thing that you can use dispatch groups for: imagine that you're displaying a nicely animated loading indicator while you do some actual work. It might happens that the work is done faster than you'd expect and the indicator animation could not finish. To solve this situation you can add a small delay task so the group will wait until both of the tasks finish. üòé</p><pre><code class="language-swift"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>.<span class="call">global</span>()
<span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()
<span class="keyword">let</span> n = <span class="number">9</span>
<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n {
    queue.<span class="call">async</span>(group: group) {
        <span class="call">print</span>(<span class="string">"</span>\(i)<span class="string">: Running async task..."</span>)
        <span class="call">sleep</span>(<span class="number">3</span>)
        <span class="call">print</span>(<span class="string">"</span>\(i)<span class="string">: Async task completed"</span>)
    }
}
group.<span class="call">wait</span>()
<span class="call">print</span>(<span class="string">"done"</span>)</code></pre><h2>Semaphores</h2><p>A <a href="https://en.wikipedia.org/wiki/Semaphore_(programming" target="_blank">semaphore</a> is simply a variable used to handle resource sharing in a concurrent system. It's a really powerful object, here are a few important examples in Swift.</p><p>How to make an async task to synchronous?</p><p>The answer is simple, you can use a semaphore (bonus point for timeouts)!</p><pre><code class="language-swift"><span class="keyword">enum</span> DispatchError: <span class="type">Error</span> {
    <span class="keyword">case</span> timeout
}

<span class="keyword">func</span> asyncMethod(completion: (<span class="type">String</span>) -&gt; <span class="type">Void</span>) {
    <span class="call">sleep</span>(<span class="number">2</span>)
    <span class="call">completion</span>(<span class="string">"done"</span>)
}

<span class="keyword">func</span> syncMethod() <span class="keyword">throws</span> -&gt; <span class="type">String</span> {

    <span class="keyword">let</span> semaphore = <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)
    <span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>.<span class="call">global</span>()

    <span class="keyword">var</span> response: <span class="type">String</span>?
    queue.<span class="call">async</span> {
        <span class="call">asyncMethod</span> { r <span class="keyword">in</span>
            response = r
            semaphore.<span class="call">signal</span>()
        }
    }
    semaphore.<span class="call">wait</span>(timeout: .<span class="call">now</span>() + <span class="number">5</span>)
    <span class="keyword">guard let</span> result = response <span class="keyword">else</span> {
        <span class="keyword">throw</span> <span class="type">DispatchError</span>.<span class="property">timeout</span>
    }
    <span class="keyword">return</span> result
}

<span class="keyword">let</span> response = <span class="keyword">try</span>? <span class="call">syncMethod</span>()
<span class="call">print</span>(response)</code></pre><h3>Lock / single access to a resource</h3><p>If you want to avoid race condition you are probably going to use <a href="https://en.wikipedia.org/wiki/Mutual_exclusion" target="_blank">mutual exclusion</a>. This could be achieved using a semaphore object, but if your object needs heavy reading capability you should consider a dispatch barrier based solution. üòú</p><pre><code class="language-swift"><span class="keyword">class</span> LockedNumbers {

    <span class="keyword">let</span> semaphore = <span class="type">DispatchSemaphore</span>(value: <span class="number">1</span>)
    <span class="keyword">var</span> elements: [<span class="type">Int</span>] = []

    <span class="keyword">func</span> append(<span class="keyword">_</span> num: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">semaphore</span>.<span class="call">wait</span>(timeout: <span class="type">DispatchTime</span>.<span class="property">distantFuture</span>)
        <span class="call">print</span>(<span class="string">"appended:</span> \(num)<span class="string">"</span>)
        <span class="keyword">self</span>.<span class="property">elements</span>.<span class="call">append</span>(num)
        <span class="keyword">self</span>.<span class="property">semaphore</span>.<span class="call">signal</span>()
    }

    <span class="keyword">func</span> removeLast() {
        <span class="keyword">self</span>.<span class="property">semaphore</span>.<span class="call">wait</span>(timeout: <span class="type">DispatchTime</span>.<span class="property">distantFuture</span>)
        <span class="keyword">defer</span> {
            <span class="keyword">self</span>.<span class="property">semaphore</span>.<span class="call">signal</span>()
        }
        <span class="keyword">guard</span> !<span class="keyword">self</span>.<span class="property">elements</span>.<span class="property">isEmpty</span> <span class="keyword">else</span> {
            <span class="keyword">return</span>
        }
        <span class="keyword">let</span> num = <span class="keyword">self</span>.<span class="property">elements</span>.<span class="call">removeLast</span>()
        <span class="call">print</span>(<span class="string">"removed:</span> \(num)<span class="string">"</span>)
    }
}

<span class="keyword">let</span> items = <span class="type">LockedNumbers</span>()
items.<span class="call">append</span>(<span class="number">1</span>)
items.<span class="call">append</span>(<span class="number">2</span>)
items.<span class="call">append</span>(<span class="number">5</span>)
items.<span class="call">append</span>(<span class="number">3</span>)
items.<span class="call">removeLast</span>()
items.<span class="call">removeLast</span>()
items.<span class="call">append</span>(<span class="number">3</span>)
<span class="call">print</span>(items.<span class="property">elements</span>)</code></pre><h3>Wait for multiple tasks to complete</h3><p>Just like with dispatch groups, you can also use a semaphore object to get notified if multiple tasks are finished. You just have to wait for it...</p><pre><code class="language-swift"><span class="keyword">let</span> semaphore = <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)
<span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>.<span class="call">global</span>()
<span class="keyword">let</span> n = <span class="number">9</span>
<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n {
    queue.<span class="call">async</span> {
        <span class="call">print</span>(<span class="string">"run</span> \(i)<span class="string">"</span>)
        <span class="call">sleep</span>(<span class="number">3</span>)
        semaphore.<span class="call">signal</span>()
    }
}
<span class="call">print</span>(<span class="string">"wait"</span>)
<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n {
    semaphore.<span class="call">wait</span>()
    <span class="call">print</span>(<span class="string">"completed</span> \(i)<span class="string">"</span>)
}
<span class="call">print</span>(<span class="string">"done"</span>)</code></pre><h3>Batch execution using a semaphore</h3><p>You can create a thread pool like behavior to simulate limited resources using a dispatch semaphore. So for example if you want to download lots of images from a server you can run a batch of x every time. Quite handy. üñê</p><pre><code class="language-swift"><span class="call">print</span>(<span class="string">"start"</span>)
<span class="keyword">let</span> sem = <span class="type">DispatchSemaphore</span>(value: <span class="number">5</span>)
<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> {
    <span class="type">DispatchQueue</span>.<span class="call">global</span>().<span class="call">async</span> {
        sem.<span class="call">wait</span>()
        <span class="call">sleep</span>(<span class="number">2</span>)
        <span class="call">print</span>(i)
        sem.<span class="call">signal</span>()
    }
}
<span class="call">print</span>(<span class="string">"end"</span>)</code></pre><h2>The DispatchSource object</h2><blockquote><p>A dispatch source is a fundamental data type that coordinates the processing of specific low-level system events.</p></blockquote><p>Signals, descriptors, processes, ports, timers and many more. Everything is handled through the <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html" target="_blank">dispatch source</a> object. I really don't want to get into the details, it's quite low-level stuff. You can monitor files, ports, signals with dispatch sources. Please just read the official Apple docs. üìÑ</p><p>I'd like to make only one example here using a <a href="https://www.cocoawithlove.com/blog/2016/07/30/timer-problems.html" target="_blank">dispatch source timer</a>.</p><pre><code class="language-swift"><span class="keyword">let</span> timer = <span class="type">DispatchSource</span>.<span class="call">makeTimerSource</span>()
timer.<span class="call">schedule</span>(deadline: .<span class="call">now</span>(), repeating: .<span class="call">seconds</span>(<span class="number">1</span>))
timer.<span class="call">setEventHandler</span> {
    <span class="call">print</span>(<span class="string">"hello"</span>)
}
timer.<span class="call">resume</span>()</code></pre><h2>Thread-safety using the dispatch framework</h2><p><a href="https://en.wikipedia.org/wiki/Thread_safety" target="_blank">Thread safety</a> is an inevitable topic if it comes to multi-threaded code. In the beginning I mentioned that there is a thread pool under the hood of GCD. Every thread has a <a href="https://izeeshan.wordpress.com/2014/07/22/nsrunloop-understanding/" target="_blank">run loop</a> object associated with it, you can even <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank">run them</a> by hand. If you create a thread manually a <a href="https://bou.io/RunRunLoopRun.html" target="_blank">run loop</a> will be added to that thread automatically.</p><pre><code class="language-swift"><span class="keyword">let</span> t = <span class="type">Thread</span> {
    <span class="call">print</span>(<span class="type">Thread</span>.<span class="property">current</span>.<span class="property">name</span> ?? <span class="string">""</span>)
     <span class="keyword">let</span> timer = <span class="type">Timer</span>(timeInterval: <span class="number">1</span>, repeats: <span class="keyword">true</span>) { t <span class="keyword">in</span>
         <span class="call">print</span>(<span class="string">"tick"</span>)
     }
     <span class="type">RunLoop</span>.<span class="property">current</span>.<span class="call">add</span>(timer, forMode: .<span class="dotAccess">defaultRunLoopMode</span>)

    <span class="type">RunLoop</span>.<span class="property">current</span>.<span class="call">run</span>()
    <span class="type">RunLoop</span>.<span class="property">current</span>.<span class="call">run</span>(mode: .<span class="dotAccess">commonModes</span>, before: <span class="type">Date</span>.<span class="property">distantPast</span>)
}
t.<span class="property">name</span> = <span class="string">"my-thread"</span>
t.<span class="call">start</span>()

<span class="comment">//RunLoop.current.run()</span></code></pre><p>You should not do this, demo purposes only, always use GCD queues!</p><h3>Queue != Thread</h3><p>A GCD queue is not a thread, if you run multiple async operations on a concurrent queue your code can run on any available thread that fits the needs.</p><blockquote><p>Thread safety is all about avoiding messed up variable states</p></blockquote><p>Imagine a mutable array in Swift. It can be modified from any thread. That's not good, because eventually the values inside of it are going to be messed up like hell if the array is not thread safe. For example multiple threads are trying to insert values to the array. What happens? If they run in parallel which element is going to be added first? Now this is why you need sometimes to create thread safe resources.</p><h3>Serial queues</h3><p>You can use a serial queue to enforce mutual exclusivity. All the tasks on the queue will run serially (in a FIFO order), only one process runs at a time and tasks have to wait for each other. One big downside of the solution is speed. üêå</p><pre><code class="language-swift"><span class="keyword">let</span> q = <span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.serial"</span>)

q.<span class="call">async</span>() {
  <span class="comment">// writes</span>
}

q.<span class="call">sync</span>() {
  <span class="comment">// reads</span>
}</code></pre><h3>Concurrent queues using barriers</h3><p>You can send a barrier task to a queue if you provide an extra flag to the async method. If a task like this arrives to the queue it'll ensure that nothing else will be executed until the barrier task have finished. To sum this up, barrier tasks are sync (points) tasks for concurrent queues. Use async barriers for writes, sync blocks for reads. üòé</p><pre><code class="language-swift"><span class="keyword">let</span> q = <span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.concurrent"</span>, attributes: .<span class="dotAccess">concurrent</span>)

q.<span class="call">async</span>(flags: .<span class="dotAccess">barrier</span>) {
  <span class="comment">// writes</span>
}

q.<span class="call">sync</span>() {
  <span class="comment">// reads</span>
}</code></pre><p>This method will result in extremely fast reads in a thread safe environment. You can also use serial queues, semaphores, locks it all depends on your current situation, but it's good to know all the available options isn't it? ü§ê</p><h2>A few anti-patterns</h2><p>You have to be very careful with <a href="https://en.wikipedia.org/wiki/Deadlock" target="_blank">deadlocks</a>, <a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank">race conditions</a> and the <a href="https://en.wikipedia.org/wiki/Readers‚Äìwriters_problem" target="_blank">readers writers problem</a>. Usually calling the sync method on a serial queue will cause you most of the troubles. Another issue is thread safety, but we've already covered that part. üòâ</p><pre><code class="language-swift"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.theswiftdev.queues.serial"</span>)

queue.<span class="call">sync</span> {
    <span class="comment">// do some sync work</span>
    queue.<span class="call">sync</span> {
        <span class="comment">// this won't be executed -&gt; deadlock!</span>
    }
}

<span class="comment">//What you are trying to do here is to launch the main thread synchronously from a background thread before it exits. This is a logical error.
//https://stackoverflow.com/questions/49258413/dispatchqueue-crashing-with-main-sync-in-swift?rq=1</span>
<span class="type">DispatchQueue</span>.<span class="call">global</span>(qos: .<span class="dotAccess">utility</span>).<span class="call">sync</span> {
    <span class="comment">// do some background task</span>
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">sync</span> {
        <span class="comment">// app will crash</span>
    }
}</code></pre><p>The Dispatch framework (aka. GCD) is an amazing one, it has such a potential and it really takes some time to master it. The real question is that what path is going to take Apple in order to embrace concurrent programming into a whole new level? <a href="https://theswiftdev.com/2019/05/28/promises-in-swift-for-beginners/">Promises</a> or async / await, maybe something <a href="https://gist.github.com/lattner/31ed37682ef1576b16bca1432ea9f782" target="_blank">entirely new</a>, let's hope that we'll see something in Swift 6.</p>
        </section>
    </div>

</article>

<section id="share" class="content-wrapper">
    <p>
    <a
        href="https://twitter.com/intent/tweet?via=tiborbodecs&amp;hashtags=SwiftLang&amp;url=https://theswiftdev.com/ultimate-grand-central-dispatch-tutorial-in-swift"
        target="_blank"
    >
        Share this article on Twitter
    </a>
    <br> Thank you. üôè</p>
</section>

<section  class="wrapper">
    <div id="book">
        <div class="column left">
            <img src="https://theswiftdev.com/assets/book/vapor.png">
        </div>
        <div class="column right">
            <h3>Get the Practical Server Side Swift book</h3>
            <p>Swift on the server is an amazing new opportunity to build fast, safe and scalable backend apps. Write your very first web-based application by using your favorite programming language. Learn how to build a modular blog engine using the latest version of the Vapor 4 framework. This book will help you to design and create modern APIs that'll allow you to share code between the server side and iOS. Start becoming a full-stack Swift developer.</p>
            <a class="button" href="https://gumroad.com/l/practical-server-side-swift" target="_blank">Available on Gumroad</a>
        </div>
    </div>
</section>

<section id="author" class="content-wrapper">
    <img 
        id="author-image"
        src="https://theswiftdev.com/images/profiles/tiborbodecs.jpg"
        alt="Picture of Tibor B√∂decs" 
        title="Tibor B√∂decs"
    >
    <h3>Tibor B√∂decs</h3>
    <p class="title">CEO @ <a href="https://binarybirds.com/">Binary Birds</a></p>
    <p class="bio">Server side Swift enthusiast, book author, content creator.</p>

    <div class="links">
        <a href="mailto:mail.tib@gmail.com?subject=theswiftdev.com" target="_blank">Email</a> ¬∑ 
        <a href="https://twitter.com/tiborbodecs" target="_blank">Twitter</a> ¬∑ 
        <a href="https://github.com/tib" target="_blank">GitHub</a> 
    </div>
</section>

        
    </main>

    <footer>
        <section class="content-wrapper">
            <img 
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >

            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p> 
                <a href="https://theswiftdev.com/">Home</a> ¬∑
                <a href="https://theswiftdev.com/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="https://theswiftdev.com/sitemap.xml" target="_blank">Sitemap</a>
            </p>
            
            <p class="small">Created by Tibor B√∂decs &copy; 2015 - 2023.</p>
        </section>
    </footer>
</body>
</html>
