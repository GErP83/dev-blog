<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Websockets for beginners using Vapor 4 and Vanilla JavaScript - The.Swift.Dev.</title>
    
    <meta name="description" content="Learn how to create a websocket server using Swift & Vapor. Multiplayer game development using JavaScript in the browser.">
    
    <meta property="og:title" content="Websockets for beginners using Vapor 4 and Vanilla JavaScript - The.Swift.Dev.">
    <meta property="og:description" content="Learn how to create a websocket server using Swift & Vapor. Multiplayer game development using JavaScript in the browser.">
    <meta property="og:url" content="https://theswiftdev.com/websockets-for-beginners-using-vapor-4-and-vanilla-javascript">
    <meta property="og:image" content="https://theswiftdev.com/images/assets/websockets-for-beginners-using-vapor-4-and-vanilla-javascript/cover.jpg">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@tiborbodecs">
    <meta name="twitter:creator" content="@tiborbodecs">
    <meta name="twitter:title" content="Websockets for beginners using Vapor 4 and Vanilla JavaScript - The.Swift.Dev.">
    <meta name="twitter:description" content="Learn how to create a websocket server using Swift & Vapor. Multiplayer game development using JavaScript in the browser.">
    <meta name="twitter:image" content="https://theswiftdev.com/images/assets/websockets-for-beginners-using-vapor-4-and-vanilla-javascript/cover.jpg">
    
    <link rel="stylesheet" href="https://theswiftdev.com/css/style.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/syntax.css">
    
    <link rel="mask-icon" sizes="any" href="https://theswiftdev.com/images/icons/icon.svg">

    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="https://theswiftdev.com/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="https://theswiftdev.com/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://theswiftdev.com/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://theswiftdev.com/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://theswiftdev.com/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://theswiftdev.com/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://theswiftdev.com/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://theswiftdev.com/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://theswiftdev.com/images/icons/apple-touch-icon-180x180.png">
    
</head>

<body>
    <a href="https://theswiftdev.gumroad.com" class="ribbon">
        üìñ
    </a>
    <header id="page-header">
        <a href="https://theswiftdev.com/">
            <img 
                id="logo-image"
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >
        </a>
    </header>
    
    <main>

        <article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2020/05/28">2020/05/28</time>
            <h1 class="title">Websockets for beginners using Vapor 4 and Vanilla JavaScript</h1>
            <p class="excerpt">Learn how to create a websocket server using Swift & Vapor. Multiplayer game development using JavaScript in the browser.</p>
            <div class="meta">
                <span class="tag">Vapor</span>
<span class="tag">websocket</span>
            </div>
        </section>
        <section class="wrapper">
            <img id="post-image" src="https://theswiftdev.com/images/assets/websockets-for-beginners-using-vapor-4-and-vanilla-javascript/cover.jpg">
        </section>
    </header>

    <div id="contents">
        <section class="content-wrapper">
            <h2>What the heck is a websocket?</h2><p>The HTTP protocol is a fundamental building block of the internet, you can use a browser to request a website using a request-response based communication model. The web browser submits a HTTP request to the server, then the server responds with a response. The response contains status information, content related headers and the message body. In most cases after you receive some kind of response the connection will be closed. End of story.</p><p>The communication model described above can be ideal for most of the websites, but what happens when you would like to constantly transmit data over the network? Just think about real-time web applications or games, they need a constant data flow between the server and the client. Initiating a connection is quite an expensive task, you could keep the connection alive with some hacky tricks, but fortunately there is a better approach. üçÄ</p><p>The <a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank">Websocket</a> communication model allows us to continuously send and receive messages in both direction (full-duplex) over a single TCP connection. A socket can be used to communicate between two different processes on different machines using standard file descriptors. This way we can have a dedicated channel to a given server through a socket and use that channel any time to deliver or receive messages instead of using requests &amp; responses.</p><p>Websockets can be used to notify the client if something happens on the server, this comes handy in many cases. If you want to build a communication heavy application such as a messenger or a multiplayer game you should definitely consider using this kind of technology.</p><h2>Websockets in Vapor 4</h2><p>Vapor 4 comes with built-in websockets support without additional dependencies. The underlying SwiftNIO framework provides the functionality, so we can hook up a websocket service into our backend app with just a few lines of Swift code. You can check the <a href="http://docs.vapor.codes/4.0/websockets/" target="_blank">official documentation</a> for the available websocket API methods, it is pretty straightforward. üíß</p><p>In this tutorial we are going to build a massively multiplayer online <a href="https://en.wikipedia.org/wiki/Tag_(game" target="_blank">tag game</a>) using websockets. Start a new project using the <code>vapor new myProject</code> command, we don't need a database driver this time. Delete the <code>routes.swift</code> file and the <code>Controllers</code> folder. Feel free to clean up the configuration method, we don't need to have anything there just yet.</p><p>The very first thing that we want to achieve is an identification system for the websocket clients. We have to uniquely identify each client so we can send messages back to them. You should create a <code>Websocket</code> folder and add a new <code>WebsocketClient.swift</code> file inside of it.</p><pre><code class="language-swift"><span class="keyword">import</span> Vapor

<span class="keyword">open class</span> WebSocketClient {
    <span class="keyword">open var</span> id: <span class="type">UUID</span>
    <span class="keyword">open var</span> socket: <span class="type">WebSocket</span>

    <span class="keyword">public init</span>(id: <span class="type">UUID</span>, socket: <span class="type">WebSocket</span>) {
        <span class="keyword">self</span>.<span class="property">id</span> = id
        <span class="keyword">self</span>.<span class="property">socket</span> = socket
    }
}</code></pre><p>We are going to store all the connected websocket clients and associate every single one with a unique identifier. The unique identifier will come from the client, but of course in a real world server you might want to ensure the uniqueness on the server side by using some kind of generator.</p><p>The next step is to provide a storage for all the connected clients. We are going to build a new <code>WebsocketClients</code> class for this purpose. This will allow us to add, remove or quickly find a given client based on the unique identifier. üîç</p><pre><code class="language-swift"><span class="keyword">import</span> Vapor

<span class="keyword">open class</span> WebsocketClients {
    <span class="keyword">var</span> eventLoop: <span class="type">EventLoop</span>
    <span class="keyword">var</span> storage: [<span class="type">UUID</span>: <span class="type">WebSocketClient</span>]
    
    <span class="keyword">var</span> active: [<span class="type">WebSocketClient</span>] {
        <span class="keyword">self</span>.<span class="property">storage</span>.<span class="property">values</span>.<span class="call">filter</span> { !$0.<span class="property">socket</span>.<span class="property">isClosed</span> }
    }

    <span class="keyword">init</span>(eventLoop: <span class="type">EventLoop</span>, clients: [<span class="type">UUID</span>: <span class="type">WebSocketClient</span>] = [:]) {
        <span class="keyword">self</span>.<span class="property">eventLoop</span> = eventLoop
        <span class="keyword">self</span>.<span class="property">storage</span> = clients
    }
    
    <span class="keyword">func</span> add(<span class="keyword">_</span> client: <span class="type">WebSocketClient</span>) {
        <span class="keyword">self</span>.<span class="property">storage</span>[client.<span class="property">id</span>] = client
    }

    <span class="keyword">func</span> remove(<span class="keyword">_</span> client: <span class="type">WebSocketClient</span>) {
        <span class="keyword">self</span>.<span class="property">storage</span>[client.<span class="property">id</span>] = <span class="keyword">nil</span>
    }
    
    <span class="keyword">func</span> find(<span class="keyword">_</span> uuid: <span class="type">UUID</span>) -&gt; <span class="type">WebSocketClient</span>? {
        <span class="keyword">self</span>.<span class="property">storage</span>[uuid]
    }

    <span class="keyword">deinit</span> {
        <span class="keyword">let</span> futures = <span class="keyword">self</span>.<span class="property">storage</span>.<span class="property">values</span>.<span class="call">map</span> { $0.<span class="property">socket</span>.<span class="call">close</span>() }
        <span class="keyword">try</span>! <span class="keyword">self</span>.<span class="property">eventLoop</span>.<span class="call">flatten</span>(futures).<span class="call">wait</span>()
    }
}</code></pre><p>We are using the <code>EventLoop</code> object to close every socket connection when we don't need them anymore. Closing a socket is an async operation that's why we have to flatten the futures and wait before all of them are closed.</p><p>Clients can send any kind of data (<code>ByteBuffer</code>) or text to the server, but it would be real nice to work with JSON objects, plus if they could provide the associated unique identifier right next to the incoming message that would have other benefits.</p><p>To make this happen we will create a generic <code>WebsocketMessage</code> object. There is a <a href="https://github.com/BastianInuk/DrinkServer/blob/master/Sources/App/Controllers/MachineController.swift" target="_blank">hacky solution</a> to decode incoming messages from JSON data. <a href="https://twitter.com/BastianInuk/" target="_blank">Bastian Inuk</a> showed me this one, but I believe it is pretty simple &amp; works like a charm. Thanks for letting me borrow your idea. üòâ</p><pre><code class="language-swift"><span class="keyword">import</span> Vapor

<span class="keyword">struct</span> WebsocketMessage&lt;T: <span class="type">Codable</span>&gt;: <span class="type">Codable</span> {
    <span class="keyword">let</span> client: <span class="type">UUID</span>
    <span class="keyword">let</span> data: <span class="type">T</span>
}

<span class="keyword">extension</span> <span class="type">ByteBuffer</span> {
    <span class="keyword">func</span> decodeWebsocketMessage&lt;T: <span class="type">Codable</span>&gt;(<span class="keyword">_</span> type: <span class="type">T</span>.<span class="type">Type</span>) -&gt; <span class="type">WebsocketMessage</span>&lt;<span class="type">T</span>&gt;? {
        <span class="keyword">try</span>? <span class="type">JSONDecoder</span>().<span class="call">decode</span>(<span class="type">WebsocketMessage</span>&lt;<span class="type">T</span>&gt;.<span class="keyword">self</span>, from: <span class="keyword">self</span>)
    }
}</code></pre><p>That's about the helpers, now we should figure out what kind of messages do we need, right?</p><p>First of all, we'd like to store a client after a successful connection event happens. We are going to use a <code>Connect</code> message for this purpose. The client will send a simple connect boolean flag, right after the connection was established so the server can save the client.</p><pre><code class="language-swift"><span class="keyword">import</span> Foundation

<span class="keyword">struct</span> Connect: <span class="type">Codable</span> {
    <span class="keyword">let</span> connect: <span class="type">Bool</span>
}</code></pre><p>We are building a game, so we need players as clients, let's subclass the <code>WebSocketClient</code> class, so we can store additional properties on it later on.</p><pre><code class="language-swift"><span class="keyword">import</span> Vapor

<span class="keyword">final class</span> PlayerClient: <span class="type">WebSocketClient</span> {
    
    <span class="keyword">public init</span>(id: <span class="type">UUID</span>, socket: <span class="type">WebSocket</span>, status: <span class="type">Status</span>) {
        <span class="keyword">super</span>.<span class="keyword">init</span>(id: id, socket: socket)
    }
}</code></pre><p>Now we have to make a <code>GameSystem</code> object that will be responsible for storing clients with associated identifiers and decoding &amp; handling incoming websocket messages.</p><pre><code class="language-swift"><span class="keyword">import</span> Vapor

<span class="keyword">class</span> GameSystem {
    <span class="keyword">var</span> clients: <span class="type">WebsocketClients</span>

    <span class="keyword">init</span>(eventLoop: <span class="type">EventLoop</span>) {
        <span class="keyword">self</span>.<span class="property">clients</span> = <span class="type">WebsocketClients</span>(eventLoop: eventLoop)
    }

    <span class="keyword">func</span> connect(<span class="keyword">_</span> ws: <span class="type">WebSocket</span>) {
        ws.<span class="call">onBinary</span> { [<span class="keyword">unowned self</span>] ws, buffer <span class="keyword">in
            if let</span> msg = buffer.<span class="call">decodeWebsocketMessage</span>(<span class="type">Connect</span>.<span class="keyword">self</span>) {
                <span class="keyword">let</span> player = <span class="type">PlayerClient</span>(id: msg.<span class="property">client</span>, socket: ws)
                <span class="keyword">self</span>.<span class="property">clients</span>.<span class="call">add</span>(player)
            }
        }
    }
}</code></pre><p>We can hook up the <code>GameSystem</code> class inside the config method to a websocket channel using the built-in <code>.webSocket</code> method, that's part of the Vapor 4 framework by default.</p><pre><code class="language-swift"><span class="keyword">import</span> Vapor

<span class="keyword">public func</span> configure(<span class="keyword">_</span> app: <span class="type">Application</span>) <span class="keyword">throws</span> {
    app.<span class="property">middleware</span>.<span class="call">use</span>(<span class="type">FileMiddleware</span>(publicDirectory: app.<span class="property">directory</span>.<span class="property">publicDirectory</span>))
    
    <span class="keyword">let</span> gameSystem = <span class="type">GameSystem</span>(eventLoop: app.<span class="property">eventLoopGroup</span>.<span class="call">next</span>())

    app.<span class="call">webSocket</span>(<span class="string">"channel"</span>) { req, ws <span class="keyword">in</span>
        gameSystem.<span class="call">connect</span>(ws)
    }
    
    app.<span class="call">get</span> { req <span class="keyword">in</span>
        req.<span class="property">view</span>.<span class="call">render</span>(<span class="string">"index.html"</span>)
    }
}</code></pre><p>We are also going to render a new view called <code>index.html</code>, the plaintext renderer is the default in Vapor so we don't have to set up Leaf if we want to display with basic HTML files.</p><pre><code class="language-html">&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;title&gt;Sockets&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div style="float: left; margin-right: 16px;"&gt;
        &lt;canvas id="canvas" width="640" height="480" style="width: 640px; height: 480px; border: 1px dashed #000;"&gt;&lt;/canvas&gt;
        &lt;div&gt;
            &lt;a href="javascript:WebSocketStart()"&gt;Start&lt;/a&gt;
            &lt;a href="javascript:WebSocketStop()"&gt;Stop&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script src="js/main.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>We can save the snippet from above under the <code>Resources/Views/index.html</code> file. The canvas will be used to render our 2d game, plus will need some additional JavaScript magic to start and stop the websocket connection using the control buttons. ‚≠êÔ∏è</p><h2>A websocket client using JavaScript</h2><p>Create a new <code>Public/js/main.js</code> file with the following contents, I'll explain everything below.</p><pre><code class="language-js">function blobToJson(blob) {
    return new Promise((resolve, reject) =&gt; {
        let fr = new FileReader();
        fr.onload = () =&gt; {
            resolve(JSON.parse(fr.result));
        };
        fr.readAsText(blob);
    });
}

function uuidv4() {
    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =&gt; (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16));
}

WebSocket.prototype.sendJsonBlob = function(data) {
    const string = JSON.stringify({ client: uuid, data: data })
    const blob = new Blob([string], {type: "application/json"});
    this.send(blob)
};

const uuid = uuidv4()
let ws = undefined

function WebSocketStart() {
    ws = new WebSocket("wss://" + window.location.host + "/channel")
    ws.onopen = () =&gt; {
        console.log("Socket is opened.");
        ws.sendJsonBlob({ connect: true })
    }

    ws.onmessage = (event) =&gt; {
        blobToJson(event.data).then((obj) =&gt; {
            console.log("Message received.");
        })
    };

    ws.onclose = () =&gt; {
        console.log("Socket is closed.");
    };
}

function WebSocketStop() {
    if ( ws !== undefined ) {
        ws.close()
    }
}
</code></pre><p>We need some helper methods to convert JSON to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank">blob</a> and vica versa. The <code>blobToJson</code> function is an asynchronous method that returns a new <code>Promise</code> with the parsed JSON value of the original binary data. In JavaScript can use the <code>.then</code> method to chain promises. üîó</p><p>The <code>uuidv4</code> method is a unique identifier generator, it's far from perfect, but we can use it to create a somewhat unique client identifier. We will call this in a few lines below.</p><p>In JavaScript you can extend a built-in functions, just like we extend structs, classes or protocols in Swift. We are extending the <code>WebSocket</code> object with a helper method to send JSON messages with the client UUID encoded as blob data (<code>sendJsonBlob</code>).</p><p>When the <code>main.js</code> file is loaded all the top level code gets executed. The <code>uuid </code>constant will be available for later use with a unique value, plus we construct a new <code>ws</code> variable to store the opened websocket connection locally. If you take a quick look at the HTML file you can see that there are two <code>onClick</code> listeners on the links, the <code>WebSocketStart</code> and <code>WebSocketStop</code> methods will be called when you click those buttons. ‚úÖ</p><p>Inside the start method we are initiating a new WebSocket connection using a URL string, we can use the <code>window.location.host</code> property to get the domain with the port. The schema should be <code>wss</code> for secure (HTTPS) connections, but you can also use the <code>ws</code> for insecure (HTTP) ones.</p><p>There are three event listeners that you can subscribe to. They work like delegates in the iOS world, once the connection is established the <code>onopen</code> handler will be called. In the callback function we send the connect message as a blob value using our previously defined helper method on the WebSocket object.</p><p>If there is an incoming message (<code>onmessage</code>) we can simply log it using the <code>console.log</code> method, if you bring up the inspector panel in a browser there is a Console tab where you will be able to see these kind of logs. If the connection is closed (<code>onclose</code>) we do the same. When the user clicks the stop button we can use the close method to manually terminate the websocket connection.</p><p>Now you can try to build &amp; run what we have so far, but don't expect more than raw logs. üòÖ</p><h2>Building a websocket game</h2><p>We will build a 2d catcher game, all the players are going to be represented as little colorful circles. A white dot will mark your own player and the catcher is going to be tagged with a black circle. Players need positions, colors and we have to send the movement controls from the client to the server side. The client will take care of the rendering, so we need to push the position of every connected player through the websocket channel. We will use a fixed size canvas for the sake of simplicity, but I'll show you how to add support for HiDPI displays. üéÆ</p><p>Let's start by updating the server, so we can store everything inside the <code>PlayerClient</code>.</p><pre><code class="language-swift"><span class="keyword">import</span> Vapor

<span class="keyword">final class</span> PlayerClient: <span class="type">WebSocketClient</span> {

    <span class="keyword">struct</span> Status: <span class="type">Codable</span> {
        <span class="keyword">var</span> id: <span class="type">UUID</span>!
        <span class="keyword">var</span> position: <span class="type">Point</span>
        <span class="keyword">var</span> color: <span class="type">String</span>
        <span class="keyword">var</span> catcher: <span class="type">Bool</span> = <span class="keyword">false
        var</span> speed = <span class="number">4</span>
    }
    
    <span class="keyword">var</span> status: <span class="type">Status</span>
    <span class="keyword">var</span> upPressed: <span class="type">Bool</span> = <span class="keyword">false
    var</span> downPressed: <span class="type">Bool</span> = <span class="keyword">false
    var</span> leftPressed: <span class="type">Bool</span> = <span class="keyword">false
    var</span> rightPressed: <span class="type">Bool</span> = <span class="keyword">false
    
    
    public init</span>(id: <span class="type">UUID</span>, socket: <span class="type">WebSocket</span>, status: <span class="type">Status</span>) {
        <span class="keyword">self</span>.<span class="property">status</span> = status
        <span class="keyword">self</span>.<span class="property">status</span>.<span class="property">id</span> = id

        <span class="keyword">super</span>.<span class="keyword">init</span>(id: id, socket: socket)
    }

    <span class="keyword">func</span> update(<span class="keyword">_</span> input: <span class="type">Input</span>) {
        <span class="keyword">switch</span> input.<span class="property">key</span> {
        <span class="keyword">case</span> .<span class="dotAccess">up</span>:
            <span class="keyword">self</span>.<span class="property">upPressed</span> = input.<span class="property">isPressed</span>
        <span class="keyword">case</span> .<span class="dotAccess">down</span>:
            <span class="keyword">self</span>.<span class="property">downPressed</span> = input.<span class="property">isPressed</span>
        <span class="keyword">case</span> .<span class="dotAccess">left</span>:
            <span class="keyword">self</span>.<span class="property">leftPressed</span> = input.<span class="property">isPressed</span>
        <span class="keyword">case</span> .<span class="dotAccess">right</span>:
            <span class="keyword">self</span>.<span class="property">rightPressed</span> = input.<span class="property">isPressed</span>
        }
    }

    <span class="keyword">func</span> updateStatus() {
        <span class="keyword">if self</span>.<span class="property">upPressed</span> {
            <span class="keyword">self</span>.<span class="property">status</span>.<span class="property">position</span>.<span class="property">y</span> = <span class="call">max</span>(<span class="number">0</span>, <span class="keyword">self</span>.<span class="property">status</span>.<span class="property">position</span>.<span class="property">y</span> - <span class="keyword">self</span>.<span class="property">status</span>.<span class="property">speed</span>)
        }
        <span class="keyword">if self</span>.<span class="property">downPressed</span> {
            <span class="keyword">self</span>.<span class="property">status</span>.<span class="property">position</span>.<span class="property">y</span> = <span class="call">min</span>(<span class="number">480</span>, <span class="keyword">self</span>.<span class="property">status</span>.<span class="property">position</span>.<span class="property">y</span> + <span class="keyword">self</span>.<span class="property">status</span>.<span class="property">speed</span>)
        }
        <span class="keyword">if self</span>.<span class="property">leftPressed</span> {
            <span class="keyword">self</span>.<span class="property">status</span>.<span class="property">position</span>.<span class="property">x</span> = <span class="call">max</span>(<span class="number">0</span>, <span class="keyword">self</span>.<span class="property">status</span>.<span class="property">position</span>.<span class="property">x</span> - <span class="keyword">self</span>.<span class="property">status</span>.<span class="property">speed</span>)
        }
        <span class="keyword">if self</span>.<span class="property">rightPressed</span> {
            <span class="keyword">self</span>.<span class="property">status</span>.<span class="property">position</span>.<span class="property">x</span> = <span class="call">min</span>(<span class="number">640</span>, <span class="keyword">self</span>.<span class="property">status</span>.<span class="property">position</span>.<span class="property">x</span> + <span class="keyword">self</span>.<span class="property">status</span>.<span class="property">speed</span>)
        }
    }
}</code></pre><p>We are going to share the status of each player in every x millisecond with the clients, so they can re-render the canvas based on the fresh data. We also need a new Input struct, so clients can send key change events to the server and we can update players based on that.</p><pre><code class="language-swift"><span class="keyword">import</span> Foundation

<span class="keyword">struct</span> Input: <span class="type">Codable</span> {

    <span class="keyword">enum</span> Key: <span class="type">String</span>, <span class="type">Codable</span> {
        <span class="keyword">case</span> up
        <span class="keyword">case</span> down
        <span class="keyword">case</span> left
        <span class="keyword">case</span> right
    }

    <span class="keyword">let</span> key: <span class="type">Key</span>
    <span class="keyword">let</span> isPressed: <span class="type">Bool</span>
}</code></pre><p>Position values are stored as points with x and y coordinates, we can build a struct for this purpose with an additional function to calculate the distance between two players. If they get too close to each other, we can pass the tag to the catched player. üéØ</p><pre><code class="language-swift"><span class="keyword">import</span> Foundation

<span class="keyword">struct</span> Point: <span class="type">Codable</span> {
    <span class="keyword">var</span> x: <span class="type">Int</span> = <span class="number">0</span>
    <span class="keyword">var</span> y: <span class="type">Int</span> = <span class="number">0</span>
    
    <span class="keyword">func</span> distance(<span class="keyword">_</span> to: <span class="type">Point</span>) -&gt; <span class="type">Float</span> {
        <span class="keyword">let</span> xDist = <span class="type">Float</span>(<span class="keyword">self</span>.<span class="property">x</span> - to.<span class="property">x</span>)
        <span class="keyword">let</span> yDist = <span class="type">Float</span>(<span class="keyword">self</span>.<span class="property">y</span> - to.<span class="property">y</span>)
        <span class="keyword">return</span> <span class="call">sqrt</span>(xDist * xDist + yDist * yDist)
    }
}</code></pre><p>Now the tricky part. The game system should be able to notify all the clients in every x milliseconds to provide a smooth 60fps experience. We can use the Dispatch framework to schedule a timer for this purpose. The other thing is that we want to avoid "tagbacks", so after one player catched another we are going to put a 2 second timeout, this way users will have some time to run away.</p><pre><code class="language-swift"><span class="keyword">import</span> Vapor
<span class="keyword">import</span> Dispatch

<span class="keyword">class</span> GameSystem {
    <span class="keyword">var</span> clients: <span class="type">WebsocketClients</span>

    <span class="keyword">var</span> timer: <span class="type">DispatchSourceTimer</span>
    <span class="keyword">var</span> timeout: <span class="type">DispatchTime</span>?
        
    <span class="keyword">init</span>(eventLoop: <span class="type">EventLoop</span>) {
        <span class="keyword">self</span>.<span class="property">clients</span> = <span class="type">WebsocketClients</span>(eventLoop: eventLoop)

        <span class="keyword">self</span>.<span class="property">timer</span> = <span class="type">DispatchSource</span>.<span class="call">makeTimerSource</span>()
        <span class="keyword">self</span>.<span class="property">timer</span>.<span class="call">setEventHandler</span> { [<span class="keyword">unowned self</span>] <span class="keyword">in
            self</span>.<span class="call">notify</span>()
        }
        <span class="keyword">self</span>.<span class="property">timer</span>.<span class="call">schedule</span>(deadline: .<span class="call">now</span>() + .<span class="call">milliseconds</span>(<span class="number">20</span>), repeating: .<span class="call">milliseconds</span>(<span class="number">20</span>))
        <span class="keyword">self</span>.<span class="property">timer</span>.<span class="call">activate</span>()
    }

    <span class="keyword">func</span> randomRGBAColor() -&gt; <span class="type">String</span> {
        <span class="keyword">let</span> range = (<span class="number">0</span>..&lt;<span class="number">255</span>)
        <span class="keyword">let</span> r = range.<span class="call">randomElement</span>()!
        <span class="keyword">let</span> g = range.<span class="call">randomElement</span>()!
        <span class="keyword">let</span> b = range.<span class="call">randomElement</span>()!
        <span class="keyword">return</span> <span class="string">"rgba(</span>\(r)<span class="string">,</span> \(g)<span class="string">,</span> \(b)<span class="string">, 1)"</span>
    }

    <span class="keyword">func</span> connect(<span class="keyword">_</span> ws: <span class="type">WebSocket</span>) {
        ws.<span class="call">onBinary</span> { [<span class="keyword">unowned self</span>] ws, buffer <span class="keyword">in
            if let</span> msg = buffer.<span class="call">decodeWebsocketMessage</span>(<span class="type">Connect</span>.<span class="keyword">self</span>) {
                <span class="keyword">let</span> catcher = <span class="keyword">self</span>.<span class="property">clients</span>.<span class="property">storage</span>.<span class="property">values</span>
                    .<span class="call">compactMap</span> { $0 <span class="keyword">as</span>? <span class="type">PlayerClient</span> }
                    .<span class="call">filter</span> { $0.<span class="property">status</span>.<span class="property">catcher</span> }
                    .<span class="dotAccess">isEmpty</span>

                <span class="keyword">let</span> player = <span class="type">PlayerClient</span>(id: msg.<span class="property">client</span>,
                                          socket: ws,
                                          status: .<span class="keyword">init</span>(position: .<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="number">0</span>),
                                                        color: <span class="keyword">self</span>.<span class="call">randomRGBAColor</span>(),
                                                        catcher: catcher))
                <span class="keyword">self</span>.<span class="property">clients</span>.<span class="call">add</span>(player)
            }

            <span class="keyword">if
                let</span> msg = buffer.<span class="call">decodeWebsocketMessage</span>(<span class="type">Input</span>.<span class="keyword">self</span>),
                <span class="keyword">let</span> player = <span class="keyword">self</span>.<span class="property">clients</span>.<span class="call">find</span>(msg.<span class="property">client</span>) <span class="keyword">as</span>? <span class="type">PlayerClient</span>
            {
                player.<span class="call">update</span>(msg.<span class="property">data</span>)
            }
        }
    }

    <span class="keyword">func</span> notify() {
        <span class="keyword">if let</span> timeout = <span class="keyword">self</span>.<span class="property">timeout</span> {
            <span class="keyword">let</span> future = timeout + .<span class="call">seconds</span>(<span class="number">2</span>)
            <span class="keyword">if</span> future &lt; <span class="type">DispatchTime</span>.<span class="call">now</span>() {
                <span class="keyword">self</span>.<span class="property">timeout</span> = <span class="keyword">nil</span>
            }
        }

        <span class="keyword">let</span> players = <span class="keyword">self</span>.<span class="property">clients</span>.<span class="property">active</span>.<span class="call">compactMap</span> { $0 <span class="keyword">as</span>? <span class="type">PlayerClient</span> }
        <span class="keyword">guard</span> !players.<span class="property">isEmpty</span> <span class="keyword">else</span> {
            <span class="keyword">return</span>
        }

        <span class="keyword">let</span> gameUpdate = players.<span class="call">map</span> { player -&gt; <span class="type">PlayerClient</span>.<span class="type">Status</span> <span class="keyword">in</span>
            player.<span class="call">updateStatus</span>()
            
            players.<span class="call">forEach</span> { otherPlayer <span class="keyword">in
                guard
                    self</span>.<span class="property">timeout</span> == <span class="keyword">nil</span>,
                    otherPlayer.<span class="property">id</span> != player.<span class="property">id</span>,
                    (player.<span class="property">status</span>.<span class="property">catcher</span> || otherPlayer.<span class="property">status</span>.<span class="property">catcher</span>),
                    otherPlayer.<span class="property">status</span>.<span class="property">position</span>.<span class="call">distance</span>(player.<span class="property">status</span>.<span class="property">position</span>) &lt; <span class="number">18</span>
                <span class="keyword">else</span> {
                    <span class="keyword">return</span>
                }
                <span class="keyword">self</span>.<span class="property">timeout</span> = <span class="type">DispatchTime</span>.<span class="call">now</span>()
                otherPlayer.<span class="property">status</span>.<span class="property">catcher</span> = !otherPlayer.<span class="property">status</span>.<span class="property">catcher</span>
                player.<span class="property">status</span>.<span class="property">catcher</span> = !player.<span class="property">status</span>.<span class="property">catcher</span>
            }
            <span class="keyword">return</span> player.<span class="property">status</span>
        }
        <span class="keyword">let</span> data = <span class="keyword">try</span>! <span class="type">JSONEncoder</span>().<span class="call">encode</span>(gameUpdate)
        players.<span class="call">forEach</span> { player <span class="keyword">in</span>
            player.<span class="property">socket</span>.<span class="call">send</span>([<span class="type">UInt8</span>](data))
        }
    }
    
    <span class="keyword">deinit</span> {
        <span class="keyword">self</span>.<span class="property">timer</span>.<span class="call">setEventHandler</span> {}
        <span class="keyword">self</span>.<span class="property">timer</span>.<span class="call">cancel</span>()
    }
}</code></pre><p>Inside the notify method we're using the built-in <code>.send</code> method on the WebSocket object to send binary data to the clients. In a chat application we would not require the whole timer logic, but we could simply notify everyone inside the onBinary block after a new incoming chat message.</p><p>The server is now ready to use, but we still have to alter the WebSocketStart method on the client side to detect key presses and releases and to render the incoming data on the canvas element.</p><pre><code class="language-js">function WebSocketStart() {

    function getScaled2DContext(canvas) {
        const ctx = canvas.getContext('2d')
        const devicePixelRatio = window.devicePixelRatio || 1
        const backingStorePixelRatio = [
            ctx.webkitBackingStorePixelRatio,
            ctx.mozBackingStorePixelRatio,
            ctx.msBackingStorePixelRatio,
            ctx.oBackingStorePixelRatio,
            ctx.backingStorePixelRatio,
            1
        ].reduce((a, b) =&gt; a || b)

        const pixelRatio = devicePixelRatio / backingStorePixelRatio
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * pixelRatio;
        canvas.height = rect.height * pixelRatio;
        ctx.scale(pixelRatio, pixelRatio);
        return ctx;
    }

    function drawOnCanvas(ctx, x, y, color, isCatcher, isLocalPlayer) {
        ctx.beginPath();
        ctx.arc(x, y, 9, 0, 2 * Math.PI, false);
        ctx.fillStyle = color;
        ctx.fill();

        if ( isCatcher ) {
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, 2 * Math.PI, false);
            ctx.fillStyle = 'black';
            ctx.fill();
        }

        if ( isLocalPlayer ) {
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, 2 * Math.PI, false);
            ctx.fillStyle = 'white';
            ctx.fill();
        }
    }


    const canvas = document.getElementById('canvas')
    const ctx = getScaled2DContext(canvas);

    ws = new WebSocket("wss://" + window.location.host + "/channel")
    ws.onopen = () =&gt; {
        console.log("Socket is opened.");
        ws.sendJsonBlob({ connect: true })
    }

    ws.onmessage = (event) =&gt; {
        blobToJson(event.data).then((obj) =&gt; {
            ctx.clearRect(0, 0, canvas.width, canvas.height)
            for (var i in obj) {
                var p = obj[i]
                const isLocalPlayer = p.id.toLowerCase() == uuid
                drawOnCanvas(ctx, p.position.x, p.position.y, p.color, p.catcher, isLocalPlayer)
            }
        })
    };

    ws.onclose = () =&gt; {
        console.log("Socket is closed.");
        ctx.clearRect(0, 0, canvas.width, canvas.height)
    };

    document.onkeydown = () =&gt; {
        switch (event.keyCode) {
            case 38: ws.sendJsonBlob({ key: 'up', isPressed: true }); break;
            case 40: ws.sendJsonBlob({ key: 'down', isPressed: true }); break;
            case 37: ws.sendJsonBlob({ key: 'left', isPressed: true }); break;
            case 39: ws.sendJsonBlob({ key: 'right', isPressed: true }); break;
        }
    }

    document.onkeyup = () =&gt; {
        switch (event.keyCode) {
            case 38: ws.sendJsonBlob({ key: 'up', isPressed: false }); break;
            case 40: ws.sendJsonBlob({ key: 'down', isPressed: false }); break;
            case 37: ws.sendJsonBlob({ key: 'left', isPressed: false }); break;
            case 39: ws.sendJsonBlob({ key: 'right', isPressed: false }); break;
        }
    }
}
</code></pre><p>The <code>getScaled2DContext</code> method will scale the canvas based on the pixel ratio, so we can draw smooth circles both on retina and standard displays. The <code>drawOnCanvas</code> method draws a player using the context at a given point. You can also draw the player with a tag and the white marker if the unique player id matches the local client identifier.</p><p>Before we connect to the socket we create a new reference using the canvas element and create a draw context. When a new message arrives we can decode it and draw the players based on the incoming status data. We clear the canvas before the render and after the connection is closed.</p><p>The last thing we have to do is to send the key press and release events to the server. We can add two listeners using the <code>document</code> variable, key codes are stored as integers, but we can map them and send right the JSON message as a blob value for the arrow keys.</p><h2>Closing thoughts</h2><p>As you can see it is relatively easy to add websocket support to an existing Vapor 4 application. Most of the time you will have to think about the architecture and the message structure instead of the Swift code. On by the way if you are setting up the backend behind an <a href="https://www.nginx.com/blog/websocket-nginx/" target="_blank">nginx proxy</a> you might have to add the <code>Upgrade</code> and <code>Connection</code> headers to the location section.</p><pre><code>server {
    location @proxy {
        proxy_pass http://127.0.0.1:8080;
        proxy_pass_header Server;
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_connect_timeout 3s;
        proxy_read_timeout 10s;
        http2_push_preload on;
    }
}
</code></pre><p>This tutorial was mostly about building a proof of concept websocket game, this was the first time I've worked with websockets using Vapor 4, but I had a lot of fun while I made this little demo. In a real-time multiplayer game you have to think about a more intelligent lag handler, you can search for the interpolation, extrapolation or lockstep keywords, but IMHO this is a good starting point.</p>
        </section>
    </div>

</article>

<section id="share" class="content-wrapper">
    <p>
    <a
        href="https://twitter.com/intent/tweet?via=tiborbodecs&amp;hashtags=SwiftLang&amp;url=https://theswiftdev.com/websockets-for-beginners-using-vapor-4-and-vanilla-javascript"
        target="_blank"
    >
        Share this article on Twitter
    </a>
    <br> Thank you. üôè</p>
</section>

<section  class="wrapper">
    <div id="book">
        <div class="column left">
            <img src="https://theswiftdev.com/images/practical-server-side-swift-cover.png">
        </div>
        <div class="column right">
            <h3>Get the Practical Server Side Swift book</h3>
            <p>Swift on the server is an amazing new opportunity to build fast, safe and scalable backend apps. Write your very first web-based application by using your favorite programming language. Learn how to build a modular blog engine using the latest version of the Vapor 4 framework. This book will help you to design and create modern APIs that'll allow you to share code between the server side and iOS. Start becoming a full-stack Swift developer.</p>
            <a class="button" href="https://gumroad.com/l/practical-server-side-swift" target="_blank">Available on Gumroad</a>
        </div>
    </div>
</section>

<section id="author" class="content-wrapper">
    <img 
        id="author-image"
        src="https://theswiftdev.com/images/profiles/tiborbodecs.jpg"
        alt="Picture of Tibor B√∂decs" 
        title="Tibor B√∂decs"
    >
    <h3>Tibor B√∂decs</h3>
    <p class="title">CEO @ <a href="https://binarybirds.com/">Binary Birds</a></p>
    <p class="bio">Server side Swift enthusiast, book author, content creator.</p>

    <div class="links">
        <a href="mailto:mail.tib@gmail.com?subject=theswiftdev.com" target="_blank">Email</a> ¬∑ 
        <a href="https://twitter.com/tiborbodecs" target="_blank">Twitter</a> ¬∑ 
        <a href="https://github.com/tib" target="_blank">GitHub</a> 
    </div>
</section>

        
    </main>

    <footer>
        <section class="content-wrapper">
            <img 
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >

            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p> 
                <a href="https://theswiftdev.com/">Home</a> ¬∑
                <a href="https://theswiftdev.com/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="https://theswiftdev.com/sitemap.xml" target="_blank">Sitemap</a>
            </p>
            
            <p class="small">Created by Tibor B√∂decs &copy; 2015 - 2023.</p>
        </section>
    </footer>
</body>
</html>
