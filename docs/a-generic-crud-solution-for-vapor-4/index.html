<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>A generic CRUD solution for Vapor 4 - The.Swift.Dev.</title>
    
    <meta name="description" content="Learn how to build a controller component that can serve models as JSON objects through a RESTful API written in Swift.">
    
    <meta property="og:title" content="A generic CRUD solution for Vapor 4 - The.Swift.Dev.">
    <meta property="og:description" content="Learn how to build a controller component that can serve models as JSON objects through a RESTful API written in Swift.">
    <meta property="og:url" content="https://theswiftdev.com/a-generic-crud-solution-for-vapor-4/">
    <meta property="og:image" content="https://theswiftdev.com/images/assets/a-generic-crud-solution-for-vapor-4/cover.jpg">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@tiborbodecs">
    <meta name="twitter:creator" content="@tiborbodecs">
    <meta name="twitter:title" content="A generic CRUD solution for Vapor 4 - The.Swift.Dev.">
    <meta name="twitter:description" content="Learn how to build a controller component that can serve models as JSON objects through a RESTful API written in Swift.">
    <meta name="twitter:image" content="https://theswiftdev.com/images/assets/a-generic-crud-solution-for-vapor-4/cover.jpg">
    
    <link rel="stylesheet" href="https://theswiftdev.com/css/style.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/syntax.css">
    
    <link rel="mask-icon" sizes="any" href="https://theswiftdev.com/images/icons/icon.svg">

    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="https://theswiftdev.com/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="https://theswiftdev.com/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://theswiftdev.com/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://theswiftdev.com/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://theswiftdev.com/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://theswiftdev.com/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://theswiftdev.com/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://theswiftdev.com/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://theswiftdev.com/images/icons/apple-touch-icon-180x180.png">
    
</head>

<body>
    <a href="https://theswiftdev.gumroad.com" class="ribbon">
        üìñ
    </a>
    <header id="page-header">
        <a href="https://theswiftdev.com/">
            <img 
                id="logo-image"
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >
        </a>
    </header>
    
    <main>

        <article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2020/04/01">2020/04/01</time>
            <h1 class="title">A generic CRUD solution for Vapor 4</h1>
            <p class="excerpt">Learn how to build a controller component that can serve models as JSON objects through a RESTful API written in Swift.</p>
            <div class="meta">
                <span class="tag">Vapor</span>
<span class="tag">CRUD</span>
            </div>
        </section>
        <section class="wrapper">
            <img id="post-image" src="https://theswiftdev.com/images/assets/a-generic-crud-solution-for-vapor-4/cover.jpg">
        </section>
    </header>

    <div id="contents">
        <section class="content-wrapper">
            <h2>CRUD ~ Create, Read, Update and Delete</h2><p>We should start by implementing the non-generic version of our code, so after we see the pattern we can turn it into a more generalized Swift code. If you start with the <a href="https://github.com/vapor/api-template" target="_blank">API template</a> project there is a pretty good example for almost everything using a Todo model.</p><p class="note">Start a new project using the <a href="http://docs.vapor.codes/3.0/getting-started/toolbox/" target="_blank">toolbox</a>, just run <code>vapor new myProject</code></p><p>Open the project by double clicking the <code>Package.swift</code> file, that'll fire up Xcode (you should be on version 11.4 or later). If you open the <code>Sources/App/Controllers</code> folder you'll find a sample controller file there called <code>TodoController.swift</code>. We're going to work on this, but first...</p><blockquote><p>A controller is a collection of request handler functions around a specific model.</p></blockquote><h2>HTTP basics: Request -&gt; Response</h2><p><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank">HTTP</a> is a text transfer protocol that is widely used around the web. In the beginning it was only used to transfer HTML files, but nowadays you can use it to request almost anything. It's mostly a stateless protocol, this means you request something, you get back a response and that's it.</p><p>It's like ordering a pizza from a place through phone. You need a number to call (URL), you pick up the phone, dial the place, the phone company initializes the connection between (you &amp; the pizza place) the two participants (the network layer does the same thing when you request an URL from a server). The phone on the other side starts ringing. üì±</p><p>Someone picks up the phone. You both introduce yourselves, also exchange some basic info such as the delivery address (server checks HTTP headers &amp; discovers what needs to be delivered to where). You tell the place what kind of pizza you'd like to have &amp; you wait for it. The place cooks the pizza (the server gathers the necessary data for the response) &amp; the pizza boy arrives with your order (the server sends back the actual response). üçï</p><blockquote><p>Everything happens asynchronously, the place (server) can fulfill multiple requests. If there is only one person who is taking orders &amp; cooking pizzas, sometimes the cooking process will be blocked by answering the phone. Anyways, using non-blocking i/o is important, that's why Vapor uses Futures &amp; Promises from <a href="https://github.com/apple/swift-nio" target="_blank">SwiftNIO</a> under the hood.</p></blockquote><p>In our case the request is a URL with some extra headers (key, value pairs) and a request body object (encoded data). The response is usually made of a HTTP status code, optional headers and response body. If we are talking about a RESTful API, the encoding of the body is usually JSON.</p><p>All right then, now you know the basics it's time to look at some Swift code.</p><h2>Contents and models in Vapor</h2><p>Defining a data structure in Swift is pretty easy, you just have to create a struct or a class. You can also convert them back and forth to JSON using the built-in <a href="https://theswiftdev.com/how-to-parse-json-in-swift-using-codable-protocol/">Codable protocol</a>. Vapor has an extension around this called Content. If you conform the the protocol (no need to implement any new functions, the object just needs to be Codable) the system can decode these objects from requests and encode them as responses.</p><p>Models on the other hand represent rows from your database. The <a href="https://theswiftdev.com/a-tutorial-for-beginners-about-the-fluent-postgresql-driver-in-vapor-4/">Fluent</a> ORM layer can take care of the low level abstractions, so you don't have to mess around with SQL queries. This is a great thing to have, read my other article if you like to know more about Fluent. üíæ</p><p>The problem starts when you have a model and it has different fields than the content. Imagine if this Todo model was a User model with a secret password field? Would you like to expose that to the public when you encode it as a response? Nope, I don't think so. üôâ</p><p>I believe that in most of the Cases the Model and the Content should be separated. Taking this one step further, the content of the request (input) and the content of the response (output) is sometimes different. I'll stop it now, let's change our Todo model according to this.</p><pre><code class="language-swift"><span class="keyword">import</span> Fluent
<span class="keyword">import</span> Vapor

<span class="keyword">final class</span> Todo: <span class="type">Model</span> {
    
    <span class="keyword">struct</span> Input: <span class="type">Content</span> {
        <span class="keyword">let</span> title: <span class="type">String</span>
    }

    <span class="keyword">struct</span> Output: <span class="type">Content</span> {
        <span class="keyword">let</span> id: <span class="type">String</span>
        <span class="keyword">let</span> title: <span class="type">String</span>
    }
    
    <span class="keyword">static let</span> schema = <span class="string">"todos"</span>

    <span class="keyword">@ID</span>(key: .<span class="dotAccess">id</span>) <span class="keyword">var</span> id: <span class="type">UUID</span>?
    <span class="keyword">@Field</span>(key: <span class="string">"title"</span>) <span class="keyword">var</span> title: <span class="type">String</span>

    <span class="keyword">init</span>() { }

    <span class="keyword">init</span>(id: <span class="type">UUID</span>? = <span class="keyword">nil</span>, title: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">id</span> = id
        <span class="keyword">self</span>.<span class="property">title</span> = title
    }
}</code></pre><p>We expect to have a title when we insert a record (we can generate the id), but when we're returning Todos we can expose the id property as well. Now back to the controller.</p><p class="warning">Don't forget to run Fluent migrations first: <code>swift run Run migrate</code></p><h3>Create</h3><p>The flow is pretty simple. Decode the Input type from the content of the request (it's created from the HTTP body) and use it to construct a new Todo class. Next save the newly created item to the database using Fluent. Finally after the save operation is done (it returns nothing by default), map the future into a proper Output, so Vapor can encode this to JSON format.</p><pre><code class="language-swift"><span class="keyword">import</span> Fluent
<span class="keyword">import</span> Vapor

<span class="keyword">struct</span> TodoController {

    <span class="comment">/*
         curl -i -X POST "http://127.0.0.1:8080/todos" \
         -H "Content-Type: application/json" \
         -d '{"title": "Hello World!"}'
     */</span>
    <span class="keyword">func</span> create(req: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Todo</span>.<span class="type">Output</span>&gt; {
        <span class="keyword">let</span> input = <span class="keyword">try</span> req.<span class="property">content</span>.<span class="call">decode</span>(<span class="type">Todo</span>.<span class="type">Input</span>.<span class="keyword">self</span>)
        <span class="keyword">let</span> todo = <span class="type">Todo</span>(title: input.<span class="property">title</span>)
        <span class="keyword">return</span> todo.<span class="call">save</span>(on: req.<span class="property">db</span>)
            .<span class="call">map</span> { <span class="type">Todo</span>.<span class="type">Output</span>(id: todo.<span class="property">id</span>!.uuidString, title: todo.<span class="property">title</span>) }
    }

    <span class="comment">// ...</span>
}</code></pre><p>I prefer cURL to quickly check my endpoints, but you can also create unit tets for this purpose. Run the server using Xcode or type <code>swift run Run</code> to the command line. Next if you copy &amp; paste the commented snippet it should create a new todo item and return the output with some additional HTTP info. You should also validate the input, but this time let's just skip that part. üòÖ</p><h3>Read</h3><p>Getting back all the <code>Todo</code> objects is a simple task, but returning a paged response is not so obvious. Fortunately with Fluent 4 we have a built-in solution for this. Let me show you how it works, but first I'd like to alter the routes a little bit.</p><pre><code class="language-swift"><span class="keyword">import</span> Fluent
<span class="keyword">import</span> Vapor

<span class="keyword">func</span> routes(<span class="keyword">_</span> app: <span class="type">Application</span>) <span class="keyword">throws</span> {
    <span class="keyword">let</span> todoController = <span class="type">TodoController</span>()
    app.<span class="call">post</span>(<span class="string">"todos"</span>, use: todoController.<span class="property">create</span>)
    app.<span class="call">get</span>(<span class="string">"todos"</span>, use: todoController.<span class="property">readAll</span>)
    app.<span class="call">get</span>(<span class="string">"todos"</span>, <span class="string">":id"</span>, use: todoController.<span class="property">read</span>)
    app.<span class="call">post</span>(<span class="string">"todos"</span>, <span class="string">":id"</span>, use: todoController.<span class="property">update</span>)
    app.<span class="call">delete</span>(<span class="string">"todos"</span>, <span class="string">":id"</span>, use: todoController.<span class="property">delete</span>)
}</code></pre><p>As you can see I tend to use read instead of index, plus <code>:id</code> is a much shorter parameter name, plus I'll already know the returned model type based on the context, no need for additional prefixes here. Ok, let me show you the controller code for the read endpoints:</p><pre><code class="language-swift"><span class="keyword">struct</span> TodoController {

    <span class="comment">/*
       curl -i -X GET "http://127.0.0.1:8080/todos?page=2&amp;per=2" \
        -H "Content-Type: application/json"
    */</span>
    <span class="keyword">func</span> readAll(req: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Page</span>&lt;<span class="type">Todo</span>.<span class="type">Output</span>&gt;&gt; {
        <span class="keyword">return</span> <span class="type">Todo</span>.<span class="call">query</span>(on: req.<span class="property">db</span>).<span class="call">paginate</span>(for: req).<span class="property">map</span> { page <span class="keyword">in</span>
            page.<span class="call">map</span> { <span class="type">Todo</span>.<span class="type">Output</span>(id: $0.<span class="property">id</span>!.uuidString, title: $0.<span class="property">title</span>) }
        }
    }

    <span class="comment">//...</span>
}</code></pre><p>As I mentioned this before Fluent helps with pagination. You can use the <code>page</code> and <code>per</code> query parameters to retrieve a page with a given number of elements. The newly returned response will contain two new (<code>items</code> &amp; <code>metadata</code>) keys. Metadata inclues the total number of items in the database. If you don't like the metadata object you can ship your own paginator:</p><pre><code class="language-swift"><span class="comment">// the first 10 items</span>
<span class="type">Todo</span>.<span class="call">query</span>(on: req.<span class="property">db</span>).<span class="call">range</span>(..&lt;<span class="number">10</span>)

<span class="comment">// returns 10 items from the 2nd element</span>
<span class="type">Todo</span>.<span class="call">query</span>(on: req.<span class="property">db</span>).<span class="call">range</span>(<span class="number">2</span>..&lt;<span class="number">10</span>).<span class="call">all</span>()

<span class="comment">// limit - offset</span>
<span class="type">Todo</span>.<span class="call">query</span>(on: req.<span class="property">db</span>).<span class="call">range</span>(offset..&lt;limit).<span class="call">all</span>()

<span class="comment">// page - per</span>
<span class="type">Todo</span>.<span class="call">query</span>(on: req.<span class="property">db</span>).<span class="call">range</span>(((page - <span class="number">1</span>) * per)..&lt;(page * per)).<span class="call">all</span>()
<span class="type">The QueryBuilder</span> range support <span class="keyword">is</span> a great addition. <span class="type">Now</span> <span class="keyword">let</span>'s talk about reading one element.

<span class="keyword">struct</span> TodoController {

    <span class="comment">/*
        curl -i -X GET "http://127.0.0.1:8080/todos/&lt;id&gt;" \
            -H "Content-Type: application/json"
     */</span>
    <span class="keyword">func</span> read(req: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Todo</span>.<span class="type">Output</span>&gt; {
        <span class="keyword">guard let</span> id = req.<span class="property">parameters</span>.<span class="call">get</span>(<span class="string">"id"</span>, as: <span class="type">UUID</span>.<span class="keyword">self</span>) <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="type">Abort</span>(.<span class="dotAccess">badRequest</span>)
        }
        <span class="keyword">return</span> <span class="type">Todo</span>.<span class="call">find</span>(id, on: req.<span class="property">db</span>)
            .<span class="call">unwrap</span>(or: <span class="type">Abort</span>(.<span class="dotAccess">notFound</span>))
            .<span class="call">map</span> { <span class="type">Todo</span>.<span class="type">Output</span>(id: $0.<span class="property">id</span>!.uuidString, title: $0.<span class="property">title</span>) }
    }

    <span class="comment">//...</span>
}</code></pre><p>You can get named parameters by key, I already mentioned this in my <a href="https://theswiftdev.com/beginners-guide-to-server-side-swift-using-vapor-4/">beginner's guide article</a>. The new thing here is that you can <code>throw Abort(error)</code> anytime you want to break something. Same thing happens in the <code>unwrap</code> method, that just checks if the value wrapped inside the future object. If it is <code>nil</code> it'll throws the given error, if the value is present the promise chain will continue.</p><h3>Update</h3><p>Update is pretty straightforward, it's somewhat the combination of the read &amp; create methods.</p><pre><code class="language-swift"><span class="keyword">struct</span> TodoController {

    <span class="comment">/*
        curl -i -X POST "http://127.0.0.1:8080/todos/&lt;id&gt;" \
            -H "Content-Type: application/json" \
            -d '{"title": "Write Vapor 4 book"}'
     */</span>
    <span class="keyword">func</span> update(req: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Todo</span>.<span class="type">Output</span>&gt; {
        <span class="keyword">guard let</span> id = req.<span class="property">parameters</span>.<span class="call">get</span>(<span class="string">"id"</span>, as: <span class="type">UUID</span>.<span class="keyword">self</span>) <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="type">Abort</span>(.<span class="dotAccess">badRequest</span>)
        }
        <span class="keyword">let</span> input = <span class="keyword">try</span> req.<span class="property">content</span>.<span class="call">decode</span>(<span class="type">Todo</span>.<span class="type">Input</span>.<span class="keyword">self</span>)
        <span class="keyword">return</span> <span class="type">Todo</span>.<span class="call">find</span>(id, on: req.<span class="property">db</span>)
            .<span class="call">unwrap</span>(or: <span class="type">Abort</span>(.<span class="dotAccess">notFound</span>))
            .<span class="call">flatMap</span> { todo <span class="keyword">in</span>
                todo.<span class="property">title</span> = input.<span class="property">title</span>
                <span class="keyword">return</span> todo.<span class="call">save</span>(on: req.<span class="property">db</span>)
                    .<span class="call">map</span> { <span class="type">Todo</span>.<span class="type">Output</span>(id: todo.<span class="property">id</span>!.uuidString, title: todo.<span class="property">title</span>) }
            }
    }
    
    <span class="comment">//...</span>
}</code></pre><p>You need an id to find the object in the database, plus some input to update the fields. You fetch the item, update the corresponding properties based on the input, save the model and finally return the newly saved version as a public output object. Piece of cake. üç∞</p><h3>Delete</h3><p>Delete is just a little bit tricky, since usually you don't return anything in the body, but just a simple status code. Vapor has a nice <code>HTTPStatus</code> enum for this purpose, so e.g. <code>.ok</code> is 200.</p><pre><code class="language-swift"><span class="keyword">struct</span> TodoController {

    <span class="comment">/*
        curl -i -X DELETE "https://127.0.0.1:8080/todos/&lt;id&gt;"
     */</span>
    <span class="keyword">func</span> delete(req: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">HTTPStatus</span>&gt; {
        <span class="keyword">guard let</span> id = req.<span class="property">parameters</span>.<span class="call">get</span>(<span class="string">"id"</span>, as: <span class="type">UUID</span>.<span class="keyword">self</span>) <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="type">Abort</span>(.<span class="dotAccess">badRequest</span>)
        }
        <span class="keyword">return</span> <span class="type">Todo</span>.<span class="call">find</span>(id, on: req.<span class="property">db</span>)
            .<span class="call">unwrap</span>(or: <span class="type">Abort</span>(.<span class="dotAccess">notFound</span>))
            .<span class="call">flatMap</span> { $0.<span class="call">delete</span>(on: req.<span class="property">db</span>) }
            .<span class="call">map</span> { .<span class="dotAccess">ok</span> }
    }

    <span class="comment">//...</span>
}</code></pre><p>Pretty much that sums everything. Of course you can extend this with a PATCH method, but that's quite a good task for practicing. I'll leave this "unimplemented" just for you... üòà</p><h2>A protocol oriented generic CRUD</h2><p>Long story short, if you introduce new models you'll have to do this exact same thing over and over again if you want to have CRUD endpoints for every single one of them.</p><p>That's a boring task to do, plus you'll end up having a lot of boilerplate code. So why not come up with a more generic solution, right? I'll show you one possible implementation.</p><pre><code class="language-swift"><span class="keyword">protocol</span> ApiModel: <span class="type">Model</span> {
    <span class="keyword">associatedtype</span> Input: <span class="type">Content</span>
    <span class="keyword">associatedtype</span> Output: <span class="type">Content</span>

    <span class="keyword">init</span>(<span class="keyword">_</span>: <span class="type">Input</span>) <span class="keyword">throws
    var</span> output: <span class="type">Output</span> { <span class="keyword">get</span> }
    <span class="keyword">func</span> update(<span class="keyword">_</span>: <span class="type">Input</span>) <span class="keyword">throws</span>
}</code></pre><p>The first thing I did is that I created a new protocol called ApiModel, it has two <code>associatedType</code> requirements, those are the i/o structs from the non-generic example. I also want to be able to initialize or update a model using an <code>Input</code> type, and transform it to an <code>Output</code>.</p><pre><code class="language-swift"><span class="keyword">protocol</span> ApiController {
    <span class="keyword">var</span> idKey: <span class="type">String</span> { <span class="keyword">get</span> }

    <span class="keyword">associatedtype</span> Model: <span class="type">ApiModel</span>

    <span class="comment">// generic helper functions</span>
    <span class="keyword">func</span> getId(<span class="keyword">_</span>: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">Model</span>.<span class="type">IDValue</span>
    <span class="keyword">func</span> find(<span class="keyword">_</span>: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Model</span>&gt;

    <span class="comment">// generic crud methods</span>
    <span class="keyword">func</span> create(<span class="keyword">_</span>: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Model</span>.<span class="type">Output</span>&gt;
    <span class="keyword">func</span> readAll(<span class="keyword">_</span>: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Page</span>&lt;<span class="type">Model</span>.<span class="type">Output</span>&gt;&gt;
    <span class="keyword">func</span> read(<span class="keyword">_</span>: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Model</span>.<span class="type">Output</span>&gt;
    <span class="keyword">func</span> update(<span class="keyword">_</span>: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Model</span>.<span class="type">Output</span>&gt;
    <span class="keyword">func</span> delete(<span class="keyword">_</span>: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">HTTPStatus</span>&gt;
    
    <span class="comment">// router helper</span>
    <span class="keyword">@discardableResult
    func</span> setup(routes: <span class="type">RoutesBuilder</span>, on endpoint: <span class="type">String</span>) -&gt; <span class="type">RoutesBuilder</span>
}</code></pre><p>Next thing todo (haha) is to come up with a controller interface. This is also going to be "generic", plus I'd like to be able to set a custom id parameter key. One small thing here is that you can't 100% generalize the decoding of the identifier parameter, but only if it's <code>LosslessStringConvertible</code>.</p><pre><code class="language-swift"><span class="keyword">extension</span> <span class="type">ApiController</span> <span class="keyword">where</span> <span class="type">Model</span>.<span class="type">IDValue</span>: <span class="type">LosslessStringConvertible</span> {

    <span class="keyword">func</span> getId(<span class="keyword">_</span> req: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">Model</span>.<span class="type">IDValue</span> {
        <span class="keyword">guard let</span> id = req.<span class="property">parameters</span>.<span class="call">get</span>(<span class="keyword">self</span>.<span class="property">idKey</span>, as: <span class="type">Model</span>.<span class="type">IDValue</span>.<span class="keyword">self</span>) <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="type">Abort</span>(.<span class="dotAccess">badRequest</span>)
        }
        <span class="keyword">return</span> id
    }
}</code></pre><p>Trust me in 99.9% of the cases you'll be just fine right with this. Final step is to have a generic version of what we've just made above with each CRUD endpoint. üëª</p><pre><code class="language-swift"><span class="keyword">extension</span> <span class="type">ApiController</span> {
    
    <span class="keyword">var</span> idKey: <span class="type">String</span> { <span class="string">"id"</span> }

    <span class="keyword">func</span> find(<span class="keyword">_</span> req: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Model</span>&gt; {
        <span class="type">Model</span>.<span class="call">find</span>(<span class="keyword">try self</span>.<span class="call">getId</span>(req), on: req.<span class="property">db</span>).<span class="call">unwrap</span>(or: <span class="type">Abort</span>(.<span class="dotAccess">notFound</span>))
    }

    <span class="keyword">func</span> create(<span class="keyword">_</span> req: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Model</span>.<span class="type">Output</span>&gt; {
        <span class="keyword">let</span> request = <span class="keyword">try</span> req.<span class="property">content</span>.<span class="call">decode</span>(<span class="type">Model</span>.<span class="type">Input</span>.<span class="keyword">self</span>)
        <span class="keyword">let</span> model = <span class="keyword">try</span> <span class="type">Model</span>(request)
        <span class="keyword">return</span> model.<span class="call">save</span>(on: req.<span class="property">db</span>).<span class="call">map</span> { <span class="keyword">_ in</span> model.<span class="property">output</span> }
    }
    
    <span class="keyword">func</span> readAll(<span class="keyword">_</span> req: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Page</span>&lt;<span class="type">Model</span>.<span class="type">Output</span>&gt;&gt; {
        <span class="type">Model</span>.<span class="call">query</span>(on: req.<span class="property">db</span>).<span class="call">paginate</span>(for: req).<span class="property">map</span> { $0.<span class="property">map</span> { $0.<span class="property">output</span> } }
    }

    <span class="keyword">func</span> read(<span class="keyword">_</span> req: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Model</span>.<span class="type">Output</span>&gt; {
        <span class="keyword">try self</span>.<span class="call">find</span>(req).<span class="call">map</span> { $0.<span class="property">output</span> }
    }

    <span class="keyword">func</span> update(<span class="keyword">_</span> req: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Model</span>.<span class="type">Output</span>&gt; {
        <span class="keyword">let</span> request = <span class="keyword">try</span> req.<span class="property">content</span>.<span class="call">decode</span>(<span class="type">Model</span>.<span class="type">Input</span>.<span class="keyword">self</span>)
        <span class="keyword">return try self</span>.<span class="call">find</span>(req).<span class="call">flatMapThrowing</span> { model -&gt; <span class="type">Model</span> <span class="keyword">in
            try</span> model.<span class="call">update</span>(request)
            <span class="keyword">return</span> model
        }
        .<span class="call">flatMap</span> { model <span class="keyword">in
            return</span> model.<span class="call">update</span>(on: req.<span class="property">db</span>).<span class="call">map</span> { model.<span class="property">output</span> }
        }
    }
    
    <span class="keyword">func</span> delete(<span class="keyword">_</span> req: <span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">HTTPStatus</span>&gt; {
        <span class="keyword">try self</span>.<span class="call">find</span>(req).<span class="call">flatMap</span> { $0.<span class="call">delete</span>(on: req.<span class="property">db</span>) }.<span class="call">map</span> { .<span class="dotAccess">ok</span> }
    }
    
    <span class="keyword">@discardableResult
    func</span> setup(routes: <span class="type">RoutesBuilder</span>, on endpoint: <span class="type">String</span>) -&gt; <span class="type">RoutesBuilder</span> {
        <span class="keyword">let</span> base = routes.<span class="call">grouped</span>(<span class="type">PathComponent</span>(stringLiteral: endpoint))
        <span class="keyword">let</span> idPathComponent = <span class="type">PathComponent</span>(stringLiteral: <span class="string">":</span>\(<span class="keyword">self</span>.<span class="property">idKey</span>)<span class="string">"</span>)
        
        base.<span class="call">post</span>(use: <span class="keyword">self</span>.<span class="property">create</span>)
        base.<span class="call">get</span>(use: <span class="keyword">self</span>.<span class="property">readAll</span>)
        base.<span class="call">get</span>(idPathComponent, use: <span class="keyword">self</span>.<span class="property">read</span>)
        base.<span class="call">post</span>(idPathComponent, use: <span class="keyword">self</span>.<span class="property">update</span>)
        base.<span class="call">delete</span>(idPathComponent, use: <span class="keyword">self</span>.<span class="property">delete</span>)

        <span class="keyword">return</span> base
    }
}</code></pre><p>Example time. Here is our generic model:</p><pre><code class="language-swift"><span class="keyword">final class</span> Todo: <span class="type">ApiModel</span> {
    
    <span class="keyword">struct</span> _Input: <span class="type">Content</span> {
        <span class="keyword">let</span> title: <span class="type">String</span>
    }

    <span class="keyword">struct</span> _Output: <span class="type">Content</span> {
        <span class="keyword">let</span> id: <span class="type">String</span>
        <span class="keyword">let</span> title: <span class="type">String</span>
    }
    
    <span class="keyword">typealias</span> Input = <span class="type">_Input</span>
    <span class="keyword">typealias</span> Output = <span class="type">_Output</span>
    
    <span class="comment">// MARK: - model</span>

    <span class="keyword">static let</span> schema = <span class="string">"todos"</span>

    <span class="keyword">@ID</span>(key: .<span class="dotAccess">id</span>) <span class="keyword">var</span> id: <span class="type">UUID</span>?
    <span class="keyword">@Field</span>(key: <span class="string">"title"</span>) <span class="keyword">var</span> title: <span class="type">String</span>

    <span class="keyword">init</span>() { }

    <span class="keyword">init</span>(id: <span class="type">UUID</span>? = <span class="keyword">nil</span>, title: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">id</span> = id
        <span class="keyword">self</span>.<span class="property">title</span> = title
    }
    
    <span class="comment">// MARK: - api</span>
    
    <span class="keyword">init</span>(<span class="keyword">_</span> input: <span class="type">Input</span>) <span class="keyword">throws</span> {
        <span class="keyword">self</span>.<span class="property">title</span> = input.<span class="property">title</span>
    }
    
    <span class="keyword">func</span> update(<span class="keyword">_</span> input: <span class="type">Input</span>) <span class="keyword">throws</span> {
        <span class="keyword">self</span>.<span class="property">title</span> = input.<span class="property">title</span>
    }
    
    <span class="keyword">var</span> output: <span class="type">Output</span> {
        .<span class="keyword">init</span>(id: <span class="keyword">self</span>.<span class="property">id</span>!.uuidString, title: <span class="keyword">self</span>.<span class="property">title</span>)
    }
}</code></pre><p class="note">If the input is the same as the output, you just need one (<code>Context</code>?) struct instead of two.</p><p>This is what's left off the controller (not much, haha):</p><pre><code class="language-swift"><span class="keyword">struct</span> TodoController: <span class="type">ApiController</span> {
    <span class="keyword">typealias</span> Model = <span class="type">Todo</span>
}</code></pre><p>The router object also shortened a bit:</p><pre><code class="language-swift"><span class="keyword">func</span> routes(<span class="keyword">_</span> app: <span class="type">Application</span>) <span class="keyword">throws</span> {
    <span class="keyword">let</span> todoController = <span class="type">TodoController</span>()
    todoController.<span class="call">setup</span>(routes: routes, on: <span class="string">"todos"</span>)
}</code></pre><p>Try to run the app, everything should work just as before.</p><p>This means that you don't have to write controllers anymore? Yes, mostly, but still this method lacks a few things, like fetching child objects for nested models or relations. If you are fine with that please go ahead and copy &amp; paste the snippets into your codebase. You won't regret, because this code is as simple as possible, plus you can override everything in your controller if you don't like the default implementation. This is the beauty of the protocol oriented approach. üòé</p><h2>Conclusion</h2><p>There is no silver bullet, but if it comes to CRUD, but please <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank">DRY</a>. Using a generic code can be a proper solution, but maybe it won't cover every single use case. Taken together I like the fact that I don't have to focus anymore on writing API endpoints, but only those that are quite unique. ü§ì</p>
        </section>
    </div>

</article>

<section id="share" class="content-wrapper">
    <p>
    <a
        href="https://twitter.com/intent/tweet?via=tiborbodecs&amp;hashtags=SwiftLang&amp;url=https://theswiftdev.com/a-generic-crud-solution-for-vapor-4/"
        target="_blank"
    >
        Share this article on Twitter
    </a>
    <br> Thank you. üôè</p>
</section>

<section  class="wrapper">
    <div id="book">
        <div class="column left">
            <img src="https://theswiftdev.com/images/practical-server-side-swift-cover.png">
        </div>
        <div class="column right">
            <h3>Get the Practical Server Side Swift book</h3>
            <p>Swift on the server is an amazing new opportunity to build fast, safe and scalable backend apps. Write your very first web-based application by using your favorite programming language. Learn how to build a modular blog engine using the latest version of the Vapor 4 framework. This book will help you to design and create modern APIs that'll allow you to share code between the server side and iOS. Start becoming a full-stack Swift developer.</p>
            <a class="button" href="https://gumroad.com/l/practical-server-side-swift" target="_blank">Available on Gumroad</a>
        </div>
    </div>
</section>

<section id="author" class="content-wrapper">
    <img 
        id="author-image"
        src="https://theswiftdev.com/images/profiles/tiborbodecs.jpg"
        alt="Picture of Tibor B√∂decs" 
        title="Tibor B√∂decs"
    >
    <h3>Tibor B√∂decs</h3>
    <p class="title">CEO @ <a href="https://binarybirds.com/">Binary Birds</a></p>
    <p class="bio">Server side Swift enthusiast, book author, content creator.</p>

    <div class="links">
        <a href="mailto:mail.tib@gmail.com?subject=theswiftdev.com" target="_blank">Email</a> ¬∑ 
        <a href="https://twitter.com/tiborbodecs" target="_blank">Twitter</a> ¬∑ 
        <a href="https://github.com/tib" target="_blank">GitHub</a> 
    </div>
</section>

        
    </main>

    <footer>
        <section class="content-wrapper">
            <img 
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >

            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p> 
                <a href="https://theswiftdev.com/">Home</a> ¬∑
                <a href="https://theswiftdev.com/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="https://theswiftdev.com/sitemap.xml" target="_blank">Sitemap</a>
            </p>
            
            <p class="small">Created by Tibor B√∂decs &copy; 2015 - 2023.</p>
        </section>
    </footer>
</body>
</html>
