<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Ultimate UICollectionView guide with iOS examples written in Swift - The.Swift.Dev.</title>
    
    <meta name="description" content="Learn how to use UICollectionView, with highly reusable UIKit components and some MVVM pattern without the going nuts with index path calculations.">
    
    <meta property="og:title" content="Ultimate UICollectionView guide with iOS examples written in Swift - The.Swift.Dev.">
    <meta property="og:description" content="Learn how to use UICollectionView, with highly reusable UIKit components and some MVVM pattern without the going nuts with index path calculations.">
    <meta property="og:url" content="https://theswiftdev.com/ultimate-uicollectionview-guide-with-ios-examples-written-in-swift/">
    <meta property="og:image" content="https://theswiftdev.com/images/assets/ultimate-uicollectionview-guide-with-ios-examples-written-in-swift/cover.jpg">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@tiborbodecs">
    <meta name="twitter:creator" content="@tiborbodecs">
    <meta name="twitter:title" content="Ultimate UICollectionView guide with iOS examples written in Swift - The.Swift.Dev.">
    <meta name="twitter:description" content="Learn how to use UICollectionView, with highly reusable UIKit components and some MVVM pattern without the going nuts with index path calculations.">
    <meta name="twitter:image" content="https://theswiftdev.com/images/assets/ultimate-uicollectionview-guide-with-ios-examples-written-in-swift/cover.jpg">
    
    <link rel="stylesheet" href="https://theswiftdev.com/css/style.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/syntax.css">
    
    <link rel="mask-icon" sizes="any" href="https://theswiftdev.com/images/icons/icon.svg">

    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="https://theswiftdev.com/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="https://theswiftdev.com/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://theswiftdev.com/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://theswiftdev.com/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://theswiftdev.com/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://theswiftdev.com/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://theswiftdev.com/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://theswiftdev.com/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://theswiftdev.com/images/icons/apple-touch-icon-180x180.png">
    
</head>

<body>
    <a href="https://theswiftdev.gumroad.com" class="ribbon">
        üìñ
    </a>
    <header id="page-header">
        <a href="https://theswiftdev.com/">
            <img 
                id="logo-image"
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >
        </a>
    </header>
    
    <main>

        <article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2018/04/17">2018/04/17</time>
            <h1 class="title">Ultimate UICollectionView guide with iOS examples written in Swift</h1>
            <p class="excerpt">Learn how to use UICollectionView, with highly reusable UIKit components and some MVVM pattern without the going nuts with index path calculations.</p>
            <div class="meta">
                <span class="tag">UIKit</span>
<span class="tag">iOS</span>
<span class="tag">UICollectionView</span>
            </div>
        </section>
        <section class="wrapper">
            <img id="post-image" src="https://theswiftdev.com/images/assets/ultimate-uicollectionview-guide-with-ios-examples-written-in-swift/cover.jpg">
        </section>
    </header>

    <div id="contents">
        <section class="content-wrapper">
            <h2>Anatomy of the UICollectionView class</h2><p>If you're not familiar with <a href="https://developer.apple.com/documentation/uikit/uicollectionview" target="_blank">UICollectionView</a>, I'd suggest to get familiar with this class immediately. They're the basic building blocks for many apps provided by Apple and other third party developers. It's like UITableView on steroids. Here is a quick intro about how to work with them through IB and Swift code. üíª</p></section><section class="wrapper">
<figure>
    <picture>
        <img class="post-image" src="https://theswiftdev.com/images/assets/ultimate-uicollectionview-guide-with-ios-examples-written-in-swift/images/layout.png" alt="Layout">
    </picture>
</figure>
</section><section class="content-wrapper"><p>You might have noticed that I have a love for metal music. In this tutorial we're going to build an Apple Music catalog like look from ground zero using only the mighty <code>UICollectionView</code> class. Headers, horizontal and vertical scrolling, circular images, so basically almost everything that you'll ever need to build great user interfaces. ü§òüèª</p><h2>How to make a UICollectionView using Interface Builder (IB) in Xcode?</h2><blockquote><p>The short &amp; honest answer: you shouldn't use IB!</p></blockquote><p>If you still want to use IB, here is a real quick tutorial for absolutely beginners:</p></section><section class="wrapper">
<figure>
    <picture>
        <img class="post-image" src="https://theswiftdev.com/images/assets/ultimate-uicollectionview-guide-with-ios-examples-written-in-swift/images/section.png" alt="Section">
    </picture>
</figure>
</section><section class="content-wrapper"><p>The main steps of creating your first UICollectionView based screen are these:</p><ul><li>Drag a UICollectionView object to your view controller</li><li>Set proper constraints on the collection view</li><li>Set dataSource &amp; delegate of the collection view</li><li>Prototype your cell layout inside the controller</li><li>Add constraints to your views inside the cell</li><li>Set prototype cell class &amp; reuse identifier</li><li>Do a little coding:</li></ul><pre><code class="language-swift"><span class="keyword">import</span> UIKit

<span class="keyword">class</span> MyCell: <span class="type">UICollectionViewCell</span> {
    <span class="keyword">@IBOutlet weak var</span> textLabel: <span class="type">UILabel</span>!
}

<span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {

    <span class="keyword">@IBOutlet weak var</span> collectionView: <span class="type">UICollectionView</span>!

    <span class="keyword">override func</span> viewDidLayoutSubviews() {
        <span class="keyword">super</span>.<span class="call">viewDidLayoutSubviews</span>()

        <span class="keyword">if let</span> flowLayout = collectionView.<span class="property">collectionViewLayout</span> <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> {
            flowLayout.<span class="property">itemSize</span> = <span class="type">CGSize</span>(
                width: collectionView.<span class="property">bounds</span>.<span class="property">width</span>,
                height: <span class="number">120</span>
            )
        }
    }
}

<span class="keyword">extension</span> <span class="type">ViewController</span>: <span class="type">UICollectionViewDataSource</span> {

    <span class="keyword">func</span> numberOfSections(
        in collectionView: <span class="type">UICollectionView</span>
    ) -&gt; <span class="type">Int</span> {
        <span class="number">1</span>
    }

    <span class="keyword">func</span> collectionView(
        <span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, 
        numberOfItemsInSection section: <span class="type">Int</span>
    ) -&gt; <span class="type">Int</span> {
        <span class="number">10</span>
    }

    <span class="keyword">func</span> collectionView(
        <span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, 
        cellForItemAt indexPath: <span class="type">IndexPath</span>
    ) -&gt; <span class="type">UICollectionViewCell</span> {
        <span class="keyword">let</span> cell = collectionView.<span class="call">dequeueReusableCell</span>(
            withReuseIdentifier: <span class="string">"MyCell"</span>, 
            for: indexPath
        ) <span class="keyword">as</span>! <span class="type">MyCell</span>

        cell.<span class="property">textLabel</span>.<span class="property">text</span> = <span class="type">String</span>(indexPath.<span class="property">row</span> + <span class="number">1</span>)
        <span class="keyword">return</span> cell
    }
}

<span class="keyword">extension</span> <span class="type">ViewController</span>: <span class="type">UICollectionViewDelegate</span> {

    <span class="keyword">func</span> collectionView(
        <span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, 
        didSelectItemAt indexPath: <span class="type">IndexPath</span>
    ) {
        <span class="call">print</span>(indexPath.<span class="property">item</span> + <span class="number">1</span>)
    }
}</code></pre><p>In a nutshell, the data source will provide all the required data about how to populate the collection view, and the delegate will handle user events, such as tapping on a cell. You should have a clear understanding about the <a href="https://developer.apple.com/documentation/uikit/uicollectionviewdatasource" target="_blank">data source</a> and <a href="https://developer.apple.com/documentation/uikit/uicollectionviewdelegate" target="_blank">delegate</a> methods, so feel free to play with them for a little while. ‚å®Ô∏è</p><h2>How to setup a UICollectionView based screen programmatically?</h2><p>As you might have noticed cells are the core components of a collection view. They are derived from reusable views, this means that if you have a list of 1000 elements, there won't be a thousand cells created for every element, but only a few that fills the size of the screen and when you scroll down the list these items are going to be reused to display your elements. This is only because of memory considerations, so unlike UIScrollView the UICollectionView (and UITableView) class is a really smart and efficient one, but this is also the reason why you have to prepare (reset the contents of) the cell every time before you display your actual data. üòâ</p><p>Initialization is also handled by the system, but it's worth to mention that if you are working with Interface Builder, you should do your customization inside the <code>awakeFromNib</code> method, but if you are using code, <code>init(frame:)</code> is your place.</p><pre><code class="language-swift"><span class="keyword">import</span> UIKit

<span class="keyword">class</span> MyCell: <span class="type">UICollectionViewCell</span> {

    <span class="keyword">weak var</span> textLabel: <span class="type">UILabel</span>!

    <span class="keyword">override init</span>(frame: <span class="type">CGRect</span>) {
        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)

        <span class="keyword">let</span> textLabel = <span class="type">UILabel</span>(frame: .<span class="dotAccess">zero</span>)
        textLabel.<span class="property">translatesAutoresizingMaskIntoConstraints</span> = <span class="keyword">false</span>
        contentView.<span class="call">addSubview</span>(textLabel)
        <span class="type">NSLayoutConstraint</span>.<span class="call">activate</span>([
            textLabel.<span class="property">topAnchor</span>.<span class="call">constraint</span>(
                equalTo: contentView.<span class="property">topAnchor</span>
            ),
            textLabel.<span class="property">bottomAnchor</span>.<span class="call">constraint</span>(
                equalTo: contentView.<span class="property">bottomAnchor</span>
            ),
            textLabel.<span class="property">leadingAnchor</span>.<span class="call">constraint</span>(
                equalTo: contentView.<span class="property">leadingAnchor</span>
            ),
            textLabel.<span class="property">trailingAnchor</span>.<span class="call">constraint</span>(
                equalTo: contentView.<span class="property">trailingAnchor</span>
            ),
        ])
        <span class="keyword">self</span>.<span class="property">textLabel</span> = textLabel

        contentView.<span class="property">backgroundColor</span> = .<span class="dotAccess">lightGray</span>
        textLabel.<span class="property">textAlignment</span> = .<span class="dotAccess">center</span>
    }

    <span class="keyword">required init</span>?(coder aDecoder: <span class="type">NSCoder</span>) {
        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)

        <span class="call">fatalError</span>(<span class="string">"Interface Builder is not supported!"</span>)
    }

    <span class="keyword">override func</span> awakeFromNib() {
        <span class="keyword">super</span>.<span class="call">awakeFromNib</span>()

        <span class="call">fatalError</span>(<span class="string">"Interface Builder is not supported!"</span>)
    }

    <span class="keyword">override func</span> prepareForReuse() {
        <span class="keyword">super</span>.<span class="call">prepareForReuse</span>()

        textLabel.<span class="property">text</span> = <span class="keyword">nil</span>
    }
}</code></pre><p>Next we have to implement the view controller which is responsible for managing the collection view, we're not using IB so we have to create it manually by <a href="https://theswiftdev.com/2018/06/14/mastering-ios-auto-layout-anchors-programmatically-from-swift/">using Auto Layout anchors</a> - like for the <code>textLabel</code> in the cell - inside the <code>loadView</code> method. After the view hierarchy is ready to rock, we also set the data source and delegate plus register our cell class for further reuse. Note that this is done automatically by the system if you are using IB, but if you prefer code you have to do it by calling the proper registration method. You can register both nibs and classes.</p><pre><code class="language-swift"><span class="keyword">import</span> UIKit

<span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {

    <span class="keyword">weak var</span> collectionView: <span class="type">UICollectionView</span>!

    <span class="keyword">override func</span> loadView() {
        <span class="keyword">super</span>.<span class="call">loadView</span>()

        <span class="keyword">let</span> collectionView = <span class="type">UICollectionView</span>(
            frame: .<span class="dotAccess">zero</span>, 
            collectionViewLayout: <span class="type">UICollectionViewFlowLayout</span>()
        )
        collectionView.<span class="property">translatesAutoresizingMaskIntoConstraints</span> = <span class="keyword">false</span>
        view.<span class="call">addSubview</span>(collectionView)
        <span class="type">NSLayoutConstraint</span>.<span class="call">activate</span>([
            collectionView.<span class="property">topAnchor</span>.<span class="call">constraint</span>(
                equalTo: view.<span class="property">topAnchor</span>
            ),
            collectionView.<span class="property">bottomAnchor</span>.<span class="call">constraint</span>(
                equalTo: view.<span class="property">bottomAnchor</span>
            ),
            collectionView.<span class="property">leadingAnchor</span>.<span class="call">constraint</span>(
                equalTo: view.<span class="property">leadingAnchor</span>
            ),
            collectionView.<span class="property">trailingAnchor</span>.<span class="call">constraint</span>(
                equalTo: view.<span class="property">trailingAnchor</span>
            ),
        ])
        <span class="keyword">self</span>.<span class="property">collectionView</span> = collectionView
    }

    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()

        collectionView.<span class="property">backgroundColor</span> = .<span class="dotAccess">white</span>
        collectionView.<span class="property">dataSource</span> = <span class="keyword">self</span>
        collectionView.<span class="property">delegate</span> = <span class="keyword">self</span>
        collectionView.<span class="call">register</span>(
            <span class="type">MyCell</span>.<span class="keyword">self</span>,
            forCellWithReuseIdentifier: <span class="string">"MyCell"</span>
        )
    }
}

<span class="keyword">extension</span> <span class="type">ViewController</span>: <span class="type">UICollectionViewDataSource</span> {

    <span class="keyword">func</span> numberOfSections(
        in collectionView: <span class="type">UICollectionView</span>
    ) -&gt; <span class="type">Int</span> {
        <span class="number">1</span>
    }

    <span class="keyword">func</span> collectionView(
        <span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, 
        numberOfItemsInSection section: <span class="type">Int</span>
    ) -&gt; <span class="type">Int</span> {
        <span class="number">10</span>
    }

    <span class="keyword">func</span> collectionView(
        <span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, 
        cellForItemAt indexPath: <span class="type">IndexPath</span>
    ) -&gt; <span class="type">UICollectionViewCell</span> {
        <span class="keyword">let</span> cell = collectionView.<span class="call">dequeueReusableCell</span>(
            withReuseIdentifier: <span class="string">"MyCell"</span>, 
            for: indexPath
        ) <span class="keyword">as</span>! <span class="type">MyCell</span>

        cell.<span class="property">textLabel</span>.<span class="property">text</span> = <span class="type">String</span>(indexPath.<span class="property">row</span> + <span class="number">1</span>)
        <span class="keyword">return</span> cell
    }
}

<span class="keyword">extension</span> <span class="type">ViewController</span>: <span class="type">UICollectionViewDelegate</span> {

    <span class="keyword">func</span> collectionView(
        <span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, 
        didSelectItemAt indexPath: <span class="type">IndexPath</span>
    ) {
        <span class="call">print</span>(indexPath.<span class="property">row</span> + <span class="number">1</span>)
    }
}

<span class="keyword">extension</span> <span class="type">ViewController</span>: <span class="type">UICollectionViewDelegateFlowLayout</span> {

    <span class="keyword">func</span> collectionView(
        <span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>,
        layout collectionViewLayout: <span class="type">UICollectionViewLayout</span>,
        sizeForItemAt indexPath: <span class="type">IndexPath</span>
    ) -&gt; <span class="type">CGSize</span> {
        .<span class="keyword">init</span>(
            width: collectionView.<span class="property">bounds</span>.<span class="property">size</span>.<span class="property">width</span> - <span class="number">16</span>, 
            height: <span class="number">120</span>
        )
    }
    <span class="keyword">func</span> collectionView(
        <span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>,
        layout collectionViewLayout: <span class="type">UICollectionViewLayout</span>,
        minimumLineSpacingForSectionAt section: <span class="type">Int</span>
    ) -&gt; <span class="type">CGFloat</span> {
        <span class="number">8</span>
    }

    <span class="keyword">func</span> collectionView(
        <span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>,
        layout collectionViewLayout: <span class="type">UICollectionViewLayout</span>,
        minimumInteritemSpacingForSectionAt section: <span class="type">Int</span>
    ) -&gt; <span class="type">CGFloat</span> {
        <span class="number">0</span>
    }

    <span class="keyword">func</span> collectionView(
        <span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>,
        layout collectionViewLayout: <span class="type">UICollectionViewLayout</span>,
        insetForSectionAt section: <span class="type">Int</span>
    ) -&gt; <span class="type">UIEdgeInsets</span> {
        .<span class="keyword">init</span>(top: <span class="number">8</span>, left: <span class="number">8</span>, bottom: <span class="number">8</span>, right: <span class="number">8</span>)
    }
}</code></pre><p>This time you should pay some attention on the flow layout delegate methods. You can use these methods to provide metrics for the layout system. The flow layout will display all the cells based on these numbers and sizes. sizeForItemAt is responsible for the cell size, <code>minimumInteritemSpacingForSectionAt</code> is the horizontal padding, <code>minimumLineSpacingForSectionAt</code> is the vertical padding, and <code>insetForSectionAt</code> is for the margin of the collection view section.</p><h2>Using supplementary elements (section headers and footers)</h2><p>So in this section I'm going to both use storyboards, nibs and some Swift code. This is my usual approach for a few reasons. Although I love making constraints from code, most people prefer visual editors, so all the cells are created inside nibs. Why nibs? Because if you have multiple collection views this is "almost" the only nice way to share cells between them.</p><p>You can create section footers exactly the same way as you do headers, so that's why this time I'm only going to focus on headers, because literally you only have to change one word in order to use footers. ‚öΩÔ∏è</p></section><section class="wrapper">
<figure>
    <picture>
        <img class="post-image" src="https://theswiftdev.com/images/assets/ultimate-uicollectionview-guide-with-ios-examples-written-in-swift/images/cell.png" alt="Cell">
    </picture>
</figure>
</section><section class="content-wrapper"><p>You just have to create two xib files, one for the cell and one for the header. Please note that you could use the exact same collection view cell to display content in the section header, but this is a demo so let's just go with two distinct items. You don't even have to set the reuse identifier from IB, because we have to register our reusable views inside the source code, so just set the cell class and connect your outlets.</p><p>Cell and supplementary element registration is slightly different for nibs.</p><pre><code class="language-swift"><span class="keyword">let</span> cellNib = <span class="type">UINib</span>(nibName: <span class="string">"Cell"</span>, bundle: <span class="keyword">nil</span>)
<span class="keyword">self</span>.<span class="property">collectionView</span>.<span class="call">register</span>(
    cellNib, 
    forCellWithReuseIdentifier: <span class="string">"Cell"</span>
)

<span class="keyword">let</span> sectionNib = <span class="type">UINib</span>(nibName: <span class="string">"Section"</span>, bundle: <span class="keyword">nil</span>)
<span class="keyword">self</span>.<span class="property">collectionView</span>.<span class="call">register</span>(
    sectionNib, 
    forSupplementaryViewOfKind: <span class="type">UICollectionView</span>.<span class="property">elementKindSectionHeader</span>, 
    withReuseIdentifier: <span class="string">"Section"</span>
)</code></pre><p>Implementing the data source for the section header looks like this.</p><pre><code class="language-swift"><span class="keyword">func</span> collectionView(
    <span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>,
    viewForSupplementaryElementOfKind kind: <span class="type">String</span>,
    at indexPath: <span class="type">IndexPath</span>
) -&gt; <span class="type">UICollectionReusableView</span> {

    <span class="keyword">guard</span> kind == <span class="type">UICollectionView</span>.<span class="property">elementKindSectionHeader</span> <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="type">UICollectionReusableView</span>()
    }
    <span class="keyword">let</span> view = collectionView.<span class="call">dequeueReusableSupplementaryView</span>(
        ofKind: kind, 
        withReuseIdentifier: <span class="string">"Section"</span>, 
        for: indexPath
    ) <span class="keyword">as</span>! <span class="type">Section</span>

    view.<span class="property">textLabel</span>.<span class="property">text</span> = <span class="type">String</span>(indexPath.<span class="property">section</span> + <span class="number">1</span>)
    <span class="keyword">return</span> view
}</code></pre><p>Providing the size for the flow layout delegate is also pretty straightforward, however sometimes I don't really get the naming conventions by Apple. Once you have to switch a kind, and the other time there are exact methods for specific kinds. ü§∑‚Äç‚ôÇÔ∏è</p><pre><code class="language-swift"><span class="keyword">func</span> collectionView(
    <span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>,
    layout collectionViewLayout: <span class="type">UICollectionViewLayout</span>,
    referenceSizeForHeaderInSection section: <span class="type">Int</span>
) -&gt; <span class="type">CGSize</span> {
    .<span class="keyword">init</span>(
        width: collectionView.<span class="property">bounds</span>.<span class="property">size</span>.<span class="property">width</span>, 
        height: <span class="number">64</span>
    )
}</code></pre><p>Starting from iOS9 section headers and footers can be pinned to the top or bottom of the visible bounds of the collection view.</p><pre><code class="language-swift"><span class="keyword">if let</span> flowLayout = <span class="keyword">self</span>.<span class="property">collectionView</span>.<span class="property">collectionViewLayout</span> <span class="keyword">as</span>? <span class="type">UICollectionViewFlowLayout</span> {
    flowLayout.<span class="property">sectionHeadersPinToVisibleBounds</span> = <span class="keyword">true</span>
}</code></pre><p>That's it, now you know how to build basic layouts with collection view.</p><p>What about complex cases, like using multiple kinds of cells in the same collection view? Things can get pretty messy with index paths, so that's why I re-invented something better based on a technique how to build <a href="https://developer.apple.com/videos/play/wwdc2014/232/" target="_blank">advanced user interfaces with collection views</a> showcased by Apple back at WWDC 2014.</p><h2>My CollectionView based UI framework</h2><p>Now you know the basics, so why don't we get straight to the point? I'll show you my best practice of building great user interfaces by using my MVVM architecture based CollectionView micro framework.</p><blockquote><p>CollectionView + ViewModel pattern = ‚ù§Ô∏è .</p></blockquote><p>I'll explain the components real quick and after that you'll learn how to use them to build up the Apple music-ish layout that I was talking about in the beginning. üé∂</p><h3>Grid system</h3><p>The first problem with collection views is the size calculation. You have to provide the size (width &amp; height) for each cell inside your collection view.</p><ul><li>if everything has a fixed size inside your collection view, you can just set the size properties on the flow layout itself</li><li>if you need dynamic sizes per item, you can implement the flow layout delegate aka. UICollectionViewDelegateFlowLayout (why is the delegate word in the middle of the name???) and return the exact sizes for the layout system</li><li>if you need even more control you can create a new layout subclass derived from CollectionView(Flow)Layout and do all the size calculations there</li></ul><p>Thats good, but still you have to mess with index paths, trait collections, frames and many more in order to have a simple 2, 4, n column layout that adapts on every device. This is the reason why I've created a really basic grid system for size calculation. With my grid class you can just set the number of columns and get back the size for x amount of columns, "just like" in web based css grid systems. üï∏</p><h3>Cell reuse</h3><p>Registering and reusing cells should and can be automated in a type safe manner. You just want to use the cell, and you shouldn't care about reuse identifiers and cell registration at all. I've made a couple helper methods in order to make the progress more pleasant. Reuse identifiers are derived from the name of the cell classes, so you dont't have to worry about anymore. This is a practice that most of the developers use.</p><h3>View model</h3><blockquote><p>view model = cell (view) + data (model)</p></blockquote><p>Filling up "template" cell with real data should be the task of a view model. This is where MVVM comes into play. I've made a generic base view model class, that you should subclass. With the help of a protocol, you can use various cells in a single collection view without going crazy of the row &amp; section calculations and you can focus on one simple task: connecting view with models. üòõ</p><h3>Section</h3><blockquote><p>section = header + footer + cells</p></blockquote><p>I'm trying to emphasize that you don't want to mess with index paths, you just want to put your data together and that's it. In the past I've struggled more than enough with "unnecessary index path math", so I've made the section object as a simple container to wrap headers, footers and all the items inside of the section. The result? Generic data source class that can be used with multiple cells without any row or section index calculations. üëèüëèüëè</p><h3>Source</h3><p>So in order to make all the things I've mentioned above work, I needed to implement the collection view delegate, data source, and flow layout delegate methods. That's how my source class was born. Everything is implemented here, and I'm using sections, view models the grid system to build up collection views. But hey, enough from this theory, let's see it in practice. üëì</p><h2>CollectionView framework example application</h2><p>How to make a any list or grid layout hassle free? Well, as a first step just add my <a href="https://github.com/corekit/collectionview" target="_blank">CollectionView framework</a> as a dependency. Don't worry you won't regret it, plus it supports Xcode 11 already, so you can use the Swift Package Manager, straight from the file menu to integrate this package.</p><p>Tip: just add the <code>@_exported import CollectionView</code> line in the AppDelegate file, then you I don't have to worry about importing the framework file-by-file.</p><h3>Step 1. Make the cell.</h3><p>This step is identical with the regular setup, except that your cell have to be a subclass of my Cell class. Add your own cell and do everything as you would do normally.</p><pre><code class="language-swift"><span class="keyword">import</span> UIKit

<span class="keyword">class</span> AlbumCell: <span class="type">Cell</span> {

    <span class="keyword">@IBOutlet weak var</span> textLabel: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet weak var</span> detailTextLabel: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet weak var</span> imageView: <span class="type">UIImageView</span>!

    <span class="keyword">override func</span> awakeFromNib() {
        <span class="keyword">super</span>.<span class="call">awakeFromNib</span>()

        <span class="keyword">self</span>.<span class="property">textLabel</span>.<span class="property">font</span> = <span class="type">UIFont</span>.<span class="call">systemFont</span>(ofSize: <span class="number">12</span>, weight: .<span class="dotAccess">bold</span>)
        <span class="keyword">self</span>.<span class="property">textLabel</span>.<span class="property">textColor</span> = .<span class="dotAccess">black</span>

        <span class="keyword">self</span>.<span class="property">detailTextLabel</span>.<span class="property">font</span> = <span class="type">UIFont</span>.<span class="call">systemFont</span>(ofSize: <span class="number">12</span>, weight: .<span class="dotAccess">bold</span>)
        <span class="keyword">self</span>.<span class="property">detailTextLabel</span>.<span class="property">textColor</span> = .<span class="dotAccess">darkGray</span>

        <span class="keyword">self</span>.<span class="property">imageView</span>.<span class="property">layer</span>.<span class="property">cornerRadius</span> = <span class="number">8</span>
        <span class="keyword">self</span>.<span class="property">imageView</span>.<span class="property">layer</span>.<span class="property">masksToBounds</span> = <span class="keyword">true</span>
    }

    <span class="keyword">override func</span> reset() {
        <span class="keyword">super</span>.<span class="call">reset</span>()

        <span class="keyword">self</span>.<span class="property">textLabel</span>.<span class="property">text</span> = <span class="keyword">nil
        self</span>.<span class="property">detailTextLabel</span>.<span class="property">text</span> = <span class="keyword">nil
        self</span>.<span class="property">imageView</span>.<span class="property">image</span> = <span class="keyword">nil</span>
    }
}</code></pre><h3>Step 2. Make a model</h3><p>Just pick a model object. It can be anything, but my approach is to make a new struct or class with a Model suffix. This way I know that models are referencing the collection view models inside my reusable components folder.</p><pre><code class="language-swift"><span class="keyword">import</span> Foundation

<span class="keyword">struct</span> AlbumModel {
    <span class="keyword">let</span> artist: <span class="type">String</span>
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span> image: <span class="type">String</span>
}</code></pre><h3>Step 3. Make the view model.</h3><p>Now instead of configuring the cell inside the delegate, or in a configure method somewhere, let's make a real view model for the cell &amp; the data model that's going to be represented via the view.</p><pre><code class="language-swift"><span class="keyword">import</span> UIKit

<span class="keyword">class</span> AlbumViewModel: <span class="type">ViewModel</span>&lt;<span class="type">AlbumCell</span>, <span class="type">AlbumModel</span>&gt; {

    <span class="keyword">override func</span> updateView() {
        <span class="keyword">self</span>.<span class="property">view</span>?.<span class="property">textLabel</span>.<span class="property">text</span> = <span class="keyword">self</span>.<span class="property">model</span>.<span class="property">artist</span>
        <span class="keyword">self</span>.<span class="property">view</span>?.<span class="property">detailTextLabel</span>.<span class="property">text</span> = <span class="keyword">self</span>.<span class="property">model</span>.<span class="property">name</span>
        <span class="keyword">self</span>.<span class="property">view</span>?.<span class="property">imageView</span>.<span class="property">image</span> = <span class="type">UIImage</span>(named: <span class="keyword">self</span>.<span class="property">model</span>.<span class="property">image</span>)
    }

    <span class="keyword">override func</span> size(grid: <span class="type">Grid</span>) -&gt; <span class="type">CGSize</span> {
        <span class="keyword">if</span>
            (<span class="keyword">self</span>.<span class="property">collectionView</span>.<span class="property">traitCollection</span>.<span class="property">userInterfaceIdiom</span> == .<span class="dotAccess">phone</span> &amp;&amp;
             <span class="keyword">self</span>.<span class="property">collectionView</span>.<span class="property">traitCollection</span>.<span class="property">verticalSizeClass</span> == .<span class="dotAccess">compact</span>) ||
            <span class="keyword">self</span>.<span class="property">collectionView</span>?.<span class="property">traitCollection</span>.<span class="property">userInterfaceIdiom</span> == .<span class="call">pad</span>
        {
            <span class="keyword">return</span> grid.<span class="call">size</span>(
                for: <span class="keyword">self</span>.<span class="property">collectionView</span>, 
                ratio: <span class="number">1.2</span>, 
                items: grid.<span class="property">columns</span> / <span class="number">4</span>, 
                gaps: grid.<span class="property">columns</span> - <span class="number">1</span>
            )
        }
        <span class="keyword">if</span> grid.<span class="property">columns</span> == <span class="number">1</span> {
            <span class="keyword">return</span> grid.<span class="call">size</span>(for: <span class="keyword">self</span>.<span class="property">collectionView</span>, ratio: <span class="number">1.1</span>)
        }
        <span class="keyword">return</span> grid.<span class="call">size</span>(
            for: <span class="keyword">self</span>.<span class="property">collectionView</span>, 
            ratio: <span class="number">1.2</span>, 
            items: grid.<span class="property">columns</span> / <span class="number">2</span>,
            gaps: grid.<span class="property">columns</span> - <span class="number">1</span>
        )
    }
}</code></pre><h3>Step 4. Setup your data source.</h3><p>Now, use your real data and populate your collection view using the view models.</p><pre><code class="language-swift"><span class="keyword">let</span> grid = <span class="type">Grid</span>(columns: <span class="number">1</span>, margin: <span class="type">UIEdgeInsets</span>(all: <span class="number">8</span>))
<span class="keyword">self</span>.<span class="property">collectionView</span>.<span class="property">source</span> = .<span class="keyword">init</span>(grid: grid, [
    [
        <span class="type">HeaderViewModel</span>(.<span class="keyword">init</span>(title: <span class="string">"Albums"</span>))
        <span class="type">AlbumViewModel</span>(<span class="keyword">self</span>.<span class="property">album</span>)
    ],
])
<span class="keyword">self</span>.<span class="property">collectionView</span>.<span class="call">reloadData</span>()</code></pre><h3>Step 5. üç∫ü§òüèªüé∏</h3><p>Congratulations you're done with your first collection view. With just a few lines of code you have a ROCK SOLID code that will help you out in most of the situations! üòé</p><blockquote><p>This is just the tip of the iceberg! üö¢</p></blockquote><h2>Horizontal scrolling inside vertical scrolling</h2><p>What if we make a cell that contains a collection view and we use the same method like above? A collection view containing a collection view... UICollectionViewception!!! üòÇ</p><p>It's completely possible, and really easy to do, the data that feeds the view model will be a collection view source object, and you're done. Effortless, magical and super nice to implement, also included in the example app.</p><h3>Sections with artists &amp; circular images</h3><p>Multiple sections? No problem, circular images? That's also a piece of cake, if you had read my previous <a href="https://theswiftdev.com/2018/01/24/uicollectionview-cells-with-circular-images-plus-rotation-support/">tutorial about circular collection view cells</a>, you'll know how to do it, but please check out the source code from GitLab and see it for yourself in action.</p><h3>Callbacks and actions</h3><p>User events can be handled very easy, because view models can have delegates or callback blocks, it only depends on you which one you prefer. The example contains an onSelect handler, which is super nice and built-in to the framework. üòé</p><h3>Dynamic cell sizing re-imagined</h3><p>I also had a <a href="https://theswiftdev.com/2018/01/23/self-sizing-cells-with-rotation-support/">tutorial about collection view self sizing cell support</a>, but to be honest I'm not a big fan of Apple's official method. After I've made the grid system and started using view models, it was more easy to calculate cell heights by myself, with about 2 lines of extra code. I believe that's worth it, because self sizing cells are a little buggy if it comes to auto rotation.</p><h3>Rotation support, adaptivity</h3><p>Don't worry about that too much, you can simply change the grid or check trait collections inside the view model if you want. I'd say almost everything can be done right out of the box. My collection view micro framework is just a lightweight wrapper around the official collection view APIs. That's the beauty of it, feel free to do whatever you want and use it in a way that YOU personally prefer. üì¶</p><p>Now go, grab the <a href="https://github.com/theswiftdev/tutorials" target="_blank">sample code</a> and listen to some metal! ü§òüèª</p><h2>What if I told you... one more thing: SwiftUI</h2><p>These are some original quotes of mine back from April, 2018:</p><blockquote><p>If you like this method that's cool, but what if I told you that there is more? Do you want to use the same pattern everywhere? I mean on iOS, tvOS, macOS and even watchOS. Done deal! I've created everything inside the CoreKit framework. UITableViews, WKInterfaceTables are supported as well.</p></blockquote><p>Well, I'm a visionary, but SwiftUI was late 1 year, it arrived in 2019:</p><blockquote><p>I really believe that Apple this year will approach the next generation UIKit / AppKit / UXKit frameworks (written in Swift of course) somewhat like this. I'm not talking about the view model pattern, but about the same API on every platform thinking. Anyway, who knows this for sue, we'll see... #wwdc18 ü§î</p></blockquote><p>If someone from Apple reads this, please explain me why the hell is SwiftUI still an abstraction layer above UIKit/ AppKit instead of a refactored AppleKit UI framework that finally unifies every single API? For real, why? Still don't get it. ü§∑‚Äç‚ôÇÔ∏è</p><p>Anyway, we're going in to the same direction guys, year-by-year I delete more and more self-written "3rd-party" code, so you're doing great progress there! üçé</p>
        </section>
    </div>

</article>

<section id="share" class="content-wrapper">
    <p>
    <a
        href="https://x.com/intent/tweet?via=tiborbodecs&amp;hashtags=SwiftLang&amp;url=https://theswiftdev.com/ultimate-uicollectionview-guide-with-ios-examples-written-in-swift/"
        target="_blank"
    >
        Share this article
    </a>
    <br> Thank you. üôè</p>
</section>

<section  class="wrapper">
    <div id="book">
        <div class="column left">
            <img src="https://theswiftdev.com/images/practical-server-side-swift-cover.png">
        </div>
        <div class="column right">
            <h3>Get the Practical Server Side Swift book</h3>
            <p>Swift on the server is an amazing new opportunity to build fast, safe and scalable backend apps. Write your very first web-based application by using your favorite programming language. Learn how to build a modular blog engine using the latest version of the Vapor 4 framework. This book will help you to design and create modern APIs that'll allow you to share code between the server side and iOS. Start becoming a full-stack Swift developer.</p>
            <a class="button" href="https://gumroad.com/l/practical-server-side-swift" target="_blank">Available on Gumroad</a>
        </div>
    </div>
</section>

<section id="author" class="content-wrapper">
    <img 
        id="author-image"
        src="https://theswiftdev.com/images/profiles/tiborbodecs.jpg"
        alt="Picture of Tibor B√∂decs" 
        title="Tibor B√∂decs"
    >
    <h3>Tibor B√∂decs</h3>
    <p class="title">CEO @ <a href="https://binarybirds.com/">Binary Birds</a></p>
    <p class="bio">Server side Swift enthusiast, book author, content creator.</p>

    <div class="links">
        <a href="mailto:mail.tib@gmail.com?subject=theswiftdev.com" target="_blank">Email</a> ¬∑ 
        <a href="https://x.com/tiborbodecs" target="_blank">X</a> ¬∑ 
        <a href="https://github.com/tib" target="_blank">GitHub</a> 
    </div>
</section>

        
    </main>

    <footer>
        <section class="content-wrapper">
            <img 
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >

            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p> 
                <a href="https://theswiftdev.com/">Home</a> ¬∑
                <a href="https://theswiftdev.com/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="https://theswiftdev.com/sitemap.xml" target="_blank">Sitemap</a>
            </p>
            
            <p class="small">Created by Tibor B√∂decs &copy; 2015 - 2023.</p>
        </section>
    </footer>
</body>
</html>
