<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>How to build SwiftUI apps using VIPER? - The.Swift.Dev.</title>
    
    <meta name="description" content="In this tutorial I'll show you how to combine SwiftUI with the VIPER architecture in a real world iOS application example.">
    
    <meta property="og:title" content="How to build SwiftUI apps using VIPER? - The.Swift.Dev.">
    <meta property="og:description" content="In this tutorial I'll show you how to combine SwiftUI with the VIPER architecture in a real world iOS application example.">
    <meta property="og:url" content="https://theswiftdev.com/how-to-build-swiftui-apps-using-viper/">
    <meta property="og:image" content="https://theswiftdev.com/images/assets/how-to-build-swiftui-apps-using-viper/cover.jpg">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@tiborbodecs">
    <meta name="twitter:creator" content="@tiborbodecs">
    <meta name="twitter:title" content="How to build SwiftUI apps using VIPER? - The.Swift.Dev.">
    <meta name="twitter:description" content="In this tutorial I'll show you how to combine SwiftUI with the VIPER architecture in a real world iOS application example.">
    <meta name="twitter:image" content="https://theswiftdev.com/images/assets/how-to-build-swiftui-apps-using-viper/cover.jpg">
    
    <link rel="stylesheet" href="https://theswiftdev.com/css/style.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/syntax.css">
    
    <link rel="mask-icon" sizes="any" href="https://theswiftdev.com/images/icons/icon.svg">

    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="https://theswiftdev.com/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="https://theswiftdev.com/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://theswiftdev.com/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://theswiftdev.com/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://theswiftdev.com/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://theswiftdev.com/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://theswiftdev.com/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://theswiftdev.com/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://theswiftdev.com/images/icons/apple-touch-icon-180x180.png">
    
</head>

<body>
    <a href="https://theswiftdev.gumroad.com" class="ribbon">
        üìñ
    </a>
    <header id="page-header">
        <a href="https://theswiftdev.com/">
            <img 
                id="logo-image"
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >
        </a>
    </header>
    
    <main>

        <article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2019/09/18">2019/09/18</time>
            <h1 class="title">How to build SwiftUI apps using VIPER?</h1>
            <p class="excerpt">In this tutorial I'll show you how to combine SwiftUI with the VIPER architecture in a real world iOS application example.</p>
            <div class="meta">
                <span class="tag">VIPER</span>
<span class="tag">SwiftUI</span>
            </div>
        </section>
        <section class="wrapper">
            <img id="post-image" src="https://theswiftdev.com/images/assets/how-to-build-swiftui-apps-using-viper/cover.jpg">
        </section>
    </header>

    <div id="contents">
        <section class="content-wrapper">
            <h2>SwiftUI - the new kid on the block</h2><p>There are literally hundreds of SwiftUI tutorials around the web, but I was only able to find just one or two that focuses on <a href="https://mecid.github.io/2019/06/05/swiftui-making-real-world-app/" target="_blank">real world</a> use cases instead of the smaller details like how to configure / make X in SwiftUI. Nice tutorials <a href="https://x.com/mecid" target="_blank">@mecid</a> keep it up!</p><p>I also had my own "struggle" with SwiftUI, because <a href="https://theswiftdev.com/2019/05/23/building-input-forms-for-ios-apps/">my collection view framework</a> is structured exactly the same way as you write SwiftUI code. After WWDC I was like, hell no! I'm doing the same method for months now, so why should I care? I started to believe that some Apple engineers are reading my blog. üòÇ</p><p>Anyway I knew at day zero that a crazy amount of new SwiftUI tutorials will arrive and everyone will be hyped about the new declarative UI framework, but honestly I already had my universal toolkit for this purpose. That's why I don't wanted to write about it. Honestly I still love Combine much more than SwiftUI. I'm also quite disappointed since CollectionView is completely missing from the framework.</p><p>Finally, just because what the heck lets try new things and I was curious about how SwiftUI can fit into my app building methodology I started to create a new VIPER template based on those kind of views. I also wanted to make a useful, scalable, modular real world application example using the new framework, which is up-to-date. A lot has changed in SwiftUI during the Xcode 11 beta period, so that's why I'm only publishing this tutorial now. Enough chatter, shouldn't we code already? üòõ</p><h2>Learn a modern VIPER architecture</h2><p>I've spent my last two years using the VIPER architecture. Some people say "it's way too complex" or "it's not a good fit for small teams". I can only tell them one word:</p><blockquote><p>Bullshit!</p></blockquote><p>I believe that I've created a modern &amp; relatively simple pattern that can be used for literally anything. Learning VIPER will definitely improve your code quality thanks to the clean architecture and the SOLID principles. You'll have a better understanding of how smaller pieces can work together and communicate with each other.</p><p>Isolated smaller components can speed up development, because you just have to work on a little piece at once, plus you can create tests for that particular thing, which is a huge win for testability &amp; code coverage (you don't have to run your app all the time if you want to test something, you can work on the module you just need).</p><p>I'm usually working with a really simple code generator to fire up new modules, this way I can save a lot of time. If you have to work alone on a project the module generator and the predefined structure can even save you some more time. Also you really can't mess up things or end up with massive files if you are following the basic VIPER rules. I'll teach you my method in about 10 minutes. ‚è∞</p><h2>What the heck is VIPER anyway?</h2><p>If you never heard about VIPER before, the first thing you should know is that a VIPER module contains the following components:</p><ul><li>View = UIViewController subclass or SwiftUI View</li><li>Interactor = Provides the required data in the proper format</li><li>Presenter = UI independent business logic (what to do exactly)</li><li>Entity = Data objects (sometimes it's missing from the module)</li><li>Router = Builds up the view controller hierarchy (show, present, dismiss, etc)</li></ul><p>I always have a module file next to these ones where I define a module builder which builds up the whole thing from the components above and in that file I also define the module specific protocols. I usually name these protocols as interfaces they make it possible that any of the components can be replaced using <a href="https://theswiftdev.com/2018/07/17/swift-dependency-injection-design-pattern/">dependency injection</a>. This way we can test anything by using mocked objects in our unit tests.</p><p class="note">Some say that a VIPER module with a Builder is called VIPER/B. I think the module file is an ideal place to store your module builder object, the module interfaces and the module delegate if you need one.</p><h2>Protocol oriented VIPER architecture</h2><p>So the key is the 6 main protocol that connects View-Interactor-Presenter-Router. These protocols ensure that none of the VIPER components can see more than it's required. If you go back to <a href="https://theswiftdev.com/2018/03/12/the-ultimate-viper-architecture-tutorial/">my first tutorial</a> you'll see that I made a mistake there. The thing is that you can call a method on the router through the presenter from the view, which is bad. This new approach fixes that issue. üêõ</p><pre><code>View-to-Presenter
Presenter-to-View

Router-to-Presenter
Presenter-to-Router

Interactor-to-Presenter
Presenter-to-Interactor


Module
# ---
builds up pointers and returns a UIViewController


View implements View-to-Presenter
# ---
strong presenter as Presenter-to-View-interface


Presenter implements Presenter-to-Router, Presenter-to-Interactor, Presenter-to-View
# ---
strong router as Router-to-Presenter-interface
strong interactor as Interactor-to-Presenter-interface
weak view as View-to-Presenter-interface


Interactor implements Interactor-to-Presenter
# ---
weak presenter as Presenter-to-Interactor-interface


Router implemenents Presenter-to-Router
# ---
weak presenter as Presenter-to-Router-interface
</code></pre><p>As you can see the view (which can be a <code>UIViewController</code> subclass) holds the presenter strongly and the presenter will retain the interactor and router classes. Everything else is a weak pointer, because we don't like retain cycles. It might seems a little bit complicated at first sight, but after writing your first few modules you'll see how nice is to separate logical components from each other. üêç</p><p>Please note that not everything is a VIPER module. Don't try to write your API communication layer or a CoreLocation service as a module, because those kind of stuff are standalone let's say: services. I'll write about them in the next one, but for now let's just focus on the anatomy of a VIPER module.</p><h2>Generic VIPER implementation in Swift 5</h2><p>Are you ready to write some Swift code? All right, let's create some generic VIPER interfaces that can be extended later on, don't be afraid won't be that hard. üòâ</p><pre><code class="language-swift"><span class="comment">// MARK: - interfaces</span>

<span class="keyword">public protocol</span> RouterPresenterInterface: <span class="keyword">class</span> {

}

<span class="keyword">public protocol</span> InteractorPresenterInterface: <span class="keyword">class</span> {

}

<span class="keyword">public protocol</span> PresenterRouterInterface: <span class="keyword">class</span> {

}

<span class="keyword">public protocol</span> PresenterInteractorInterface: <span class="keyword">class</span> {

}

<span class="keyword">public protocol</span> PresenterViewInterface: <span class="keyword">class</span> {

}

<span class="keyword">public protocol</span> ViewPresenterInterface: <span class="keyword">class</span> {

}

<span class="comment">// MARK: - viper</span>

<span class="keyword">public protocol</span> RouterInterface: <span class="type">RouterPresenterInterface</span> {
    <span class="keyword">associatedtype</span> PresenterRouter

    <span class="keyword">var</span> presenter: <span class="type">PresenterRouter</span>! { <span class="keyword">get set</span> }
}

<span class="keyword">public protocol</span> InteractorInterface: <span class="type">InteractorPresenterInterface</span> {
    <span class="keyword">associatedtype</span> PresenterInteractor

    <span class="keyword">var</span> presenter: <span class="type">PresenterInteractor</span>! { <span class="keyword">get set</span> }
}

<span class="keyword">public protocol</span> PresenterInterface: <span class="type">PresenterRouterInterface</span> &amp; <span class="type">PresenterInteractorInterface</span> &amp; <span class="type">PresenterViewInterface</span> {
    <span class="keyword">associatedtype</span> RouterPresenter
    <span class="keyword">associatedtype</span> InteractorPresenter
    <span class="keyword">associatedtype</span> ViewPresenter

    <span class="keyword">var</span> router: <span class="type">RouterPresenter</span>! { <span class="keyword">get set</span> }
    <span class="keyword">var</span> interactor: <span class="type">InteractorPresenter</span>! { <span class="keyword">get set</span> }
    <span class="keyword">var</span> view: <span class="type">ViewPresenter</span>! { <span class="keyword">get set</span> }
}

<span class="keyword">public protocol</span> ViewInterface: <span class="type">ViewPresenterInterface</span> {
    <span class="keyword">associatedtype</span> PresenterView

    <span class="keyword">var</span> presenter: <span class="type">PresenterView</span>! { <span class="keyword">get set</span> }
}

<span class="keyword">public protocol</span> EntityInterface {

}

<span class="comment">// MARK: - module</span>

<span class="keyword">public protocol</span> ModuleInterface {

    <span class="keyword">associatedtype</span> View <span class="keyword">where</span> <span class="type">View</span>: <span class="type">ViewInterface</span>
    <span class="keyword">associatedtype</span> Presenter <span class="keyword">where</span> <span class="type">Presenter</span>: <span class="type">PresenterInterface</span>
    <span class="keyword">associatedtype</span> Router <span class="keyword">where</span> <span class="type">Router</span>: <span class="type">RouterInterface</span>
    <span class="keyword">associatedtype</span> Interactor <span class="keyword">where</span> <span class="type">Interactor</span>: <span class="type">InteractorInterface</span>

    <span class="keyword">func</span> assemble(view: <span class="type">View</span>, presenter: <span class="type">Presenter</span>, router: <span class="type">Router</span>, interactor: <span class="type">Interactor</span>)
}

<span class="keyword">public extension</span> <span class="type">ModuleInterface</span> {

    <span class="keyword">func</span> assemble(view: <span class="type">View</span>, presenter: <span class="type">Presenter</span>, router: <span class="type">Router</span>, interactor: <span class="type">Interactor</span>) {
        view.<span class="property">presenter</span> = (presenter <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">View</span>.<span class="type">PresenterView</span>)

        presenter.<span class="property">view</span> = (view <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Presenter</span>.<span class="type">ViewPresenter</span>)
        presenter.<span class="property">interactor</span> = (interactor <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Presenter</span>.<span class="type">InteractorPresenter</span>)
        presenter.<span class="property">router</span> = (router <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Presenter</span>.<span class="type">RouterPresenter</span>)

        interactor.<span class="property">presenter</span> = (presenter <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Interactor</span>.<span class="type">PresenterInteractor</span>)

        router.<span class="property">presenter</span> = (presenter <span class="keyword">as</span>! <span class="type">Self</span>.<span class="type">Router</span>.<span class="type">PresenterRouter</span>)
    }
}</code></pre><p>Associated types are just placeholders for specific types, by using a generic interface design I can assemble my modules with a generic module interface extension and if some protocol is missing the app will crash just as I try to initialize the bad module.</p><p>I love this approach, because it saves me from a lot of boilerplate module builder code. Also this way everything will have a base protocol, so I can extend anything in a really neat protocol oriented way. Anyway if you don't understand generics that's not a big deal, in the actual module implementation you will barely meet them.</p><p>So how does an actual module looks like?</p><pre><code class="language-swift"><span class="comment">// TodoModule.swift

// MARK: - router</span>

<span class="keyword">protocol</span> TodoRouterPresenterInterface: <span class="type">RouterPresenterInterface</span> {

}

<span class="comment">// MARK: - presenter</span>

<span class="keyword">protocol</span> TodoPresenterRouterInterface: <span class="type">PresenterRouterInterface</span> {

}

<span class="keyword">protocol</span> TodoPresenterInteractorInterface: <span class="type">PresenterInteractorInterface</span> {

}

<span class="keyword">protocol</span> TodoPresenterViewInterface: <span class="type">PresenterViewInterface</span> {

}

<span class="comment">// MARK: - interactor</span>

<span class="keyword">protocol</span> TodoInteractorPresenterInterface: <span class="type">InteractorPresenterInterface</span> {

}

<span class="comment">// MARK: - view</span>

<span class="keyword">protocol</span> TodoViewPresenterInterface: <span class="type">ViewPresenterInterface</span> {

}


<span class="comment">// MARK: - module builder</span>

<span class="keyword">final class</span> TodoModule: <span class="type">ModuleInterface</span> {

    <span class="keyword">typealias</span> View = <span class="type">TodoView</span>
    <span class="keyword">typealias</span> Presenter = <span class="type">TodoPresenter</span>
    <span class="keyword">typealias</span> Router = <span class="type">TodoRouter</span>
    <span class="keyword">typealias</span> Interactor = <span class="type">TodoInteractor</span>

    <span class="keyword">func</span> build() -&gt; <span class="type">UIViewController</span> {
        <span class="keyword">let</span> view = <span class="type">View</span>()
        <span class="keyword">let</span> interactor = <span class="type">Interactor</span>()
        <span class="keyword">let</span> presenter = <span class="type">Presenter</span>()
        <span class="keyword">let</span> router = <span class="type">Router</span>()

        <span class="keyword">self</span>.<span class="call">assemble</span>(view: view, presenter: presenter, router: router, interactor: interactor)

        router.<span class="property">viewController</span> = view

        <span class="keyword">return</span> view
    }
}


<span class="comment">// TodoPresenter.swift</span>

<span class="keyword">final class</span> TodoPresenter: <span class="type">PresenterInterface</span> {
    <span class="keyword">var</span> router: <span class="type">TodoRouterPresenterInterface</span>!
    <span class="keyword">var</span> interactor: <span class="type">TodoInteractorPresenterInterface</span>!
    <span class="keyword">weak var</span> view: <span class="type">TodoViewPresenterInterface</span>!
}

<span class="keyword">extension</span> <span class="type">TodoPresenter</span>: <span class="type">TodoPresenterRouterInterface</span> {

}

<span class="keyword">extension</span> <span class="type">TodoPresenter</span>: <span class="type">TodoPresenterInteractorInterface</span> {

}

<span class="keyword">extension</span> <span class="type">TodoPresenter</span>: <span class="type">TodoPresenterViewInterface</span> {

}

<span class="comment">// TodoInteractor.swift</span>

<span class="keyword">final class</span> TodoInteractor: <span class="type">InteractorInterface</span> {
    <span class="keyword">weak var</span> presenter: <span class="type">TodoPresenterInteractorInterface</span>!
}

<span class="keyword">extension</span> <span class="type">TodoInteractor</span>: <span class="type">TodoInteractorPresenterInterface</span> {

}

<span class="comment">// TodoRouter.swift</span>

<span class="keyword">final class</span> TodoRouter: <span class="type">RouterInterface</span> {
    <span class="keyword">weak var</span> presenter: <span class="type">TodoPresenterRouterInterface</span>!
    <span class="keyword">weak var</span> viewController: <span class="type">UIViewController</span>?
}

<span class="keyword">extension</span> <span class="type">TodoRouter</span>: <span class="type">TodoRouterPresenterInterface</span> {

}

<span class="comment">// TodoView.swift</span>

<span class="keyword">final class</span> TodoView: <span class="type">UIViewController</span>, <span class="type">ViewInterface</span> {
    <span class="keyword">var</span> presenter: <span class="type">TodoPresenterViewInterface</span>!
}

<span class="keyword">extension</span> <span class="type">TodoView</span>: <span class="type">TodoViewPresenterInterface</span> {

}</code></pre><p>A VIPER module is made from five files, which is a huge improvement compared to my old method (I used 9 files for a single module, which is still better than a 2000 lines of code massive view controller, but yeah it was quite many files... üòÇ ).</p><p>You can use my <a href="https://github.com/corekit/viper" target="_blank">VIPER protocol library</a> if you want or simply copy &amp; paste these interfaces to your project. I also have a <a href="https://github.com/corekit/vipera" target="_blank">module generator</a> written entirely in Swift that can generate a module based on this template (or you can make your own).</p><h2>How to build VIPER interfaces?</h2><p>Let me explain a sample flow real quick, consider the following example:</p><pre><code class="language-swift"><span class="keyword">protocol</span> TodoRouterPresenterInterface: <span class="type">RouterPresenterInterface</span> {
    <span class="keyword">func</span> dismiss()
}

<span class="comment">// MARK: - presenter</span>

<span class="keyword">protocol</span> TodoPresenterRouterInterface: <span class="type">PresenterRouterInterface</span> {

}

<span class="keyword">protocol</span> TodoPresenterInteractorInterface: <span class="type">PresenterInteractorInterface</span> {
    <span class="keyword">func</span> didLoadWelcomeText(<span class="keyword">_</span> text: <span class="type">String</span>)
}

<span class="keyword">protocol</span> TodoPresenterViewInterface: <span class="type">PresenterViewInterface</span> {
    <span class="keyword">func</span> ready()
    <span class="keyword">func</span> close()
}

<span class="comment">// MARK: - interactor</span>

<span class="keyword">protocol</span> TodoInteractorPresenterInterface: <span class="type">InteractorPresenterInterface</span> {
    <span class="keyword">func</span> startLoadingWelcomeText()
}

<span class="comment">// MARK: - view</span>

<span class="keyword">protocol</span> TodoViewPresenterInterface: <span class="type">ViewPresenterInterface</span> {
    <span class="keyword">func</span> setLoadingIndicator(visible: <span class="type">Bool</span>)
    <span class="keyword">func</span> setWelcomeText(<span class="keyword">_</span> text: <span class="type">String</span>)
}</code></pre><p>The view calls <code>ready()</code> on the presenter at some point in time <code>viewDidLoad()</code>, so the presenter can kick off. First it tells the view to show the loading indicator by calling setLoadingIndicator(visible: true), next asks the interactor to load the welcome text asynchronously <code>startLoadingWelcomeText()</code>. After the data arrives back to the interactor it can notify the presenter by using the <code>didLoadWelcomeText("")</code> method. The presenter can now tell the view to hide the loading indicator using the same method <code>setLoadingIndicator(visible: false)</code> this time with a false parameter and to display the welcome text by using <code>setWelcomeText("")</code>.</p><p>Another use case is that someone taps a button on the view in order to close the controller. The view calls <code>close()</code> on the presenter, and the presenter can simply call dismiss() on the router. The presenter can also do some other stuff (like cleaning up some resources) before it asks the router to dismiss the view controller.</p><p>I hope that you get the example, feel fee to implement everything by your own, it's quite a nice task to practice. Of course you can utilize blocks, promises or the brand new Combine framework to make your live more easy. You can for example auto-notify the presenter if some async data loading have finished. üòâ</p><p>So now that you have a basic understanding about a modern VIPER architecture lets talk about how to replace the traditional ViewController subclass with SwiftUI.</p><h2>How to design a VIPER based SwiftUI application?</h2><p>SwiftUI is quite a unique beast. View are structs so our generic VIPER protocol needs some alterations in order to make everything work.</p><p>The first thing you have to do is to get rid of the ViewPresenterInterface protocol. Next you can remove the view property from the PresenterInterface since we're going to use an observable view-model pattern to auto-update the view with data. The last modification is that you have to remove the view parameter from the default implementation of the assemble function inside the ModuleInterface extension.</p><p>So I mentioned a view-model, let's make one. For the sake of simplicity I'm going to use an error Bool to indicate if something went wrong, but you could use another view, or a standalone VIPER module that presents an alert message.</p><pre><code class="language-swift"><span class="keyword">import</span> Combine
<span class="keyword">import</span> SwiftUI

<span class="keyword">final class</span> TodoViewModel: <span class="type">ObservableObject</span> {

    <span class="keyword">let</span> objectWillChange = <span class="type">ObservableObjectPublisher</span>()

    <span class="keyword">@Published var</span> error: <span class="type">Bool</span> = <span class="keyword">false</span> {
        <span class="keyword">willSet</span> {
            <span class="keyword">self</span>.<span class="property">objectWillChange</span>.<span class="call">send</span>()
        }
    }

    <span class="keyword">@Published var</span> todos: [<span class="type">TodoEntity</span>] = [] {
       <span class="keyword">willSet</span> {
            <span class="keyword">self</span>.<span class="property">objectWillChange</span>.<span class="call">send</span>()
        }
    }
}</code></pre><p>This class conforms to the <code>ObservableObject</code> which makes SwiftUI possible to check for updates &amp; re-render the view hierarchy if something changed. You just need a property with the ObservableObjectPublisher type and literally <code>send()</code> a message if something will change this trigger the auto-update in your views. üî•</p><p>The <code>TodoEntity</code> is just a basic struct that conforms to a bunch of protocols like the new Identifiable from SwiftUI, because we'd like to display entities in a list.</p><pre><code class="language-swift"><span class="keyword">import</span> Foundation
<span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> TodoEntity: <span class="type">EntityInterface</span>, <span class="type">Codable</span>, <span class="type">Identifiable</span> {
    <span class="keyword">let</span> id: <span class="type">Int</span>
    <span class="keyword">let</span> title: <span class="type">String</span>
    <span class="keyword">let</span> completed: <span class="type">Bool</span>
}</code></pre><p>A basic SwiftUI view will still implement the <code>ViewInterface</code> and it'll have a reference to the presenter. Our view-model property is also going to be used here marked with an <code>@ObservedObject</code> property wrapper. This is how it looks like in code so far:</p><pre><code class="language-swift"><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> TodoView: <span class="type">ViewInterface</span>, <span class="type">View</span> {

    <span class="keyword">var</span> presenter: <span class="type">TodoPresenterViewInterface</span>!

    <span class="keyword">@ObservedObject var</span> viewModel: <span class="type">TodoViewModel</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Text</span>(<span class="string">"SwiftUI ‚ù§Ô∏è VIPER"</span>)
    }
}</code></pre><p>The presenter will also have a <code>weak var viewModel: TodoViewModel!</code> reference to be able to update the the view-model. Seems like we have a two-way communication flow between the view and the presenter by using a view-model. Looks good to me. üëç</p><p>We can also utilize the brand new <code>@EnvironmentObject</code> if we want to pass around some data in the view hierarchy. You just have to implement the same observation protocol in your environment object that we did for the view-model. For example:</p><pre><code class="language-swift"><span class="keyword">import</span> Foundation
<span class="keyword">import</span> Combine

<span class="keyword">final class</span> TodoEnvironment: <span class="type">ObservableObject</span> {

    <span class="keyword">let</span> objectWillChange = <span class="type">ObservableObjectPublisher</span>()

    <span class="keyword">@Published var</span> title: <span class="type">String</span> = <span class="string">"Todo list"</span> {
       <span class="keyword">willSet</span> {
            <span class="keyword">self</span>.<span class="property">objectWillChange</span>.<span class="call">send</span>()
        }
    }
}</code></pre><p>Finally let me show you how to implement the module builder, because that's quite tricky. You have to use the new generic <code>UIHostingController</code>, which is thankfully an <code>UIViewController</code> subclass so you can return it after you finish module building.</p><pre><code class="language-swift"><span class="keyword">final class</span> TodoModule: <span class="type">ModuleInterface</span> {
    <span class="keyword">typealias</span> View = <span class="type">TodoView</span>
    <span class="keyword">typealias</span> Presenter = <span class="type">TodoPresenter</span>
    <span class="keyword">typealias</span> Router = <span class="type">TodoRouter</span>
    <span class="keyword">typealias</span> Interactor = <span class="type">TodoInteractor</span>

    <span class="keyword">func</span> build() -&gt; <span class="type">UIViewController</span> {
        <span class="keyword">let</span> presenter = <span class="type">Presenter</span>()
        <span class="keyword">let</span> interactor = <span class="type">Interactor</span>()
        <span class="keyword">let</span> router = <span class="type">Router</span>()

        <span class="keyword">let</span> viewModel = <span class="type">TodoViewModel</span>()
        <span class="keyword">let</span> view = <span class="type">View</span>(presenter: presenter, viewModel: viewModel)
            .<span class="call">environmentObject</span>(<span class="type">TodoEnvironment</span>())
        presenter.<span class="property">viewModel</span> = viewModel

        <span class="keyword">self</span>.<span class="call">assemble</span>(presenter: presenter, router: router, interactor: interactor)

        <span class="keyword">let</span> viewController = <span class="type">UIHostingController</span>(rootView: view)
        router.<span class="property">viewController</span> = viewController
        <span class="keyword">return</span> viewController
    }
}</code></pre><p>Putting together the pieces from now is just a piece of cake. If you want, you can challenge yourself to build something without downloading the <a href="https://github.com/theswiftdev/tutorials/tree/master/VIPER/VIPERAndSwiftUI" target="_blank">final project</a>. üç∞</p><p>Well, if you're not into challenges that's fine too, feel free to grab the example code from The.Swift.Dev tutorials on <a href="https://github.com/theswiftdev/tutorials/" target="_blank">GitHub</a>. It contains a nice interactor with some cool networking stuff <a href="https://theswiftdev.com/2019/08/15/urlsession-and-the-combine-framework/">using URLSession and the Combine framework</a>. The final SwiftUI code is just a rough implementation, because as I told you in the beginning there are really good tutorials about SwiftUI with examples.</p>
        </section>
    </div>

</article>

<section id="share" class="content-wrapper">
    <p>
    <a
        href="https://x.com/intent/tweet?via=tiborbodecs&amp;hashtags=SwiftLang&amp;url=https://theswiftdev.com/how-to-build-swiftui-apps-using-viper/"
        target="_blank"
    >
        Share this article
    </a>
    <br> Thank you. üôè</p>
</section>

<section  class="wrapper">
    <div id="book">
        <div class="column left">
            <img src="https://theswiftdev.com/images/practical-server-side-swift-cover.png">
        </div>
        <div class="column right">
            <h3>Get the Practical Server Side Swift book</h3>
            <p>Swift on the server is an amazing new opportunity to build fast, safe and scalable backend apps. Write your very first web-based application by using your favorite programming language. Learn how to build a modular blog engine using the latest version of the Vapor 4 framework. This book will help you to design and create modern APIs that'll allow you to share code between the server side and iOS. Start becoming a full-stack Swift developer.</p>
            <a class="button" href="https://gumroad.com/l/practical-server-side-swift" target="_blank">Available on Gumroad</a>
        </div>
    </div>
</section>

<section id="author" class="content-wrapper">
    <img 
        id="author-image"
        src="https://theswiftdev.com/images/profiles/tiborbodecs.jpg"
        alt="Picture of Tibor B√∂decs" 
        title="Tibor B√∂decs"
    >
    <h3>Tibor B√∂decs</h3>
    <p class="title">CEO @ <a href="https://binarybirds.com/">Binary Birds</a></p>
    <p class="bio">Server side Swift enthusiast, book author, content creator.</p>

    <div class="links">
        <a href="mailto:mail.tib@gmail.com?subject=theswiftdev.com" target="_blank">Email</a> ¬∑ 
        <a href="https://x.com/tiborbodecs" target="_blank">X</a> ¬∑ 
        <a href="https://github.com/tib" target="_blank">GitHub</a> 
    </div>
</section>

        
    </main>

    <footer>
        <section class="content-wrapper">
            <img 
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >

            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p> 
                <a href="https://theswiftdev.com/">Home</a> ¬∑
                <a href="https://theswiftdev.com/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="https://theswiftdev.com/sitemap.xml" target="_blank">Sitemap</a>
            </p>
            
            <p class="small">Created by Tibor B√∂decs &copy; 2015 - 2023.</p>
        </section>
    </footer>
</body>
</html>
